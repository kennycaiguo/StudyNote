www.timexz.com

PHP:Hypertext Preprocessor 超文本预处理器
PHP是嵌入式脚本语言

httpd d代表deamon，意思是后台运行的程序

x86 代表适合32位操作系统
No_ssl 不支持https
msi 是Windows下的一种可执行文件

www.baidu.com是二级域名
baidu.com是一级域名
baidu是域名，.com代表属于com组织的

Network Domain 域名
Server Name 服务器名

服务器：安装了特定服务器软件的计算机称为服务器

php-5.3.28-win32-vc9-x86.zip
win32 windows平台
vc9 使用visual studio 2008编译的

可以编写定时运行的php程序，在Linux下加入到crontab，在Windows下加入到计划任务

整合Apache和PHP
1、将PHP加入到Apache的模块中
LoadModule 模块名 模块文件名

在php压缩包中有php5apache2_2.dll和php5apache2_4，2_2代表Apache2.2，2_4代表Apache2_4

dll是动态链接库文件

2、告诉Apache何时调用PHP预处理器
我们使用一个标签
<FilesMatch 匹配文件后缀>
	SetHandler PHP的模块句柄
</FilesMatch>

如果在一个php文件中调用系统函数phpinfo得到php的相关配置信息，里面显示
Configuration File(php.ini) Path为C:/Windows 这个不用管，这个是php建议放在C:/Windows下，但是我们不这样做
Loaded Configuration File为none 这个是需要重点关注的

PHPIniDir "D:/wamp/php/php.ini"

手动解决时区错误
Warning: phpinfo() [function.phpinfo]: It is not safe to rely on the system's timezone settings.

date.timezone = Asia/Shanghai

修改php配置文件也需要重启Apache

浏览器里面直接输入localhost域名，会默认访问index.html，当自己配置虚拟主机时需要进行如下配置
<Directory "D:/wamp/apache/htdocs">
    Options Indexes FollowSymLinks
    AllowOverride None
    Order allow,deny
    Allow from all
	
	DirectoryIndex index.html  //在这里设置一个页面
</Directory>

分布式配置文件
分布在站点目录中的配置文件：.htaccess文件
分布式配置文件可以设置Apache及虚拟主机的一些参数，而且分布式配置文件等级最高，可以覆盖主配置文件的配置

可以通过新建一个文件保存成.htaccess文件来创建以点开头的文件
此时要注意将Directory里面的AllowOverride设置为All


在分布式配置文件中修改PHP的配置参数
有两个选项可以修改PHP的配置
PHP flag开关类型配置选项 on|off|1|0
PHP value字符串类型的配置选项

php_flag session.auto_start on
php_value include_path "f:/php0421/shop"

纯php文件一定要将最后的结束标识省略

mysql_connect("localhost","root","123456");
mysql_query("set names utf8");
mysql_query("select * from student_info");
Array([student_id]=>1 [student_name]=>zhang);

mysql_fetch_assoc($result);//键值数组格式
Array([student_id]=>1 [student_name]=>zhang);

mysql_fetch_row($result); //下标数组格式
Array([0]=>1 [1]=>zhang);

mysql_fetch_array($result);//既有下标 又有数组

mysql_fetch_object($result);//返回对象
Object([student_id]=>1 [student_name]=>zhang);

mysql_close($link);//断开连接 注意不是关闭连接

==============================================

MySQLDB的封装
class MySQLDB{
	public $host;
	public $port;
	public $user;
	public $pass;
	public $charset;
	public $dbname;
	public $link;
	
	public function __contruct($options){
		$this->host=isset($options["host"]) ? $options["host"] : "127.0.0.1";
		$this->port=isset($options["port"]) ? $options["port"] : "3306";
		$this->user=isset($options["user"]) ? $options["user"] : ""; //默认为匿名用户
		$this->pass=isset($options["pass"]) ? $options["pass"] : "";
		$this->charset=isset($options["charset"]) ? $options["charset"] : "utf8";
		$this->dbname=isset($options["dbname"]) ? $options["dbname"] : "";
		
		if($link=mysql_connect("$this->host:$this->port",$this->user,$this->pass)){
			$this->link=$link;
		}else{
			echo "数据库连接失败";
			die;
			return false;
		}
		
		$sql="set names $this->charset";
		if(!mysql_query($sql,$this->link)){
			echo "SQL执行失败";
		}
		
		$sql="use `$this->dbname`";
		if(!mysql_query($sql,$this->link)){
			echo "SQL执行失败";
		}
	}
}
$config=array(
	"host"=>"127.0.0.1",
	"port"=>"3306",
	"user"=>"root",
	"pass"=>"1234",
	"charset"=>"utf8",
	"dbname"=>"test"
);
$db=new MySQLDB($config);

==============================================

主机解析URL，分发路由，确定交给哪个平台哪个控制器的哪个方法处理
查询到结果之后再返回给客户端
↓	↑
转交给控制器	对于控制器而言，把相同的功能提取出来，定义一个总控制器，其他控制器继承自它
↓	↑
模型	上传类	验证码类	
↓	↑
数据库连接
↓	↑
数据库


项目目录结构
shopcz
	application	应用程序目录
		controllers
			home		前台
			admin		后台
		models
		views
			home		前台
			admin		后台
		config		配置目录
	framework	框架目录
		core
		database
		libraries	验证码类 上传类放在这里
		helpers		工具函数
	public		公共资源目录
		images
		style
		js
		upload
	index.php	入口文件
	
单一入口	
index.php?p=admin&c=goods&c=add

framework/core:
Framework.class.php
<?php
class Framework{
	//定义一个主方法
	public static function run(){
		self::init();
		self::autoload();
		self::dispatch();
	}

	//1 项目初始化
	private static function init(){
		//定义数据常量
		//define("ROOT_PATH",getcwd()."/");
		//DIRECTORY_SEPARATOR 实际上就是正斜线
		define("ROOT_PATH",getcwd().DIRECTORY_SEPARATOR);//根目录
		define("FRAMEWORK_PATH",		ROOT_PATH."framework".DIRECTORY_SEPARATOR);//框架目录
		define("APP_PATH",				ROOT_PATH."application".DIRECTORY_SEPARATOR);
		define("CORE_PATH",				ROOT_PATH."core".DIRECTORY_SEPARATOR);
		define("DB_PATH",				FRAMEWORK_PATH."database".DIRECTORY_SEPARATOR);
		define("LIB_PATH",				FRAMEWORK_PATH."libraries".DIRECTORY_SEPARATOR);
		define("HELPER_PATH",			FRAMEWORK_PATH."helpers".DIRECTORY_SEPARATOR);
		define("CONTROLLER_PATH",		APP_PATH."controllers".DIRECTORY_SEPARATOR);
		define("MODEL_PATH",			APP_PATH."model".DIRECTORY_SEPARATOR);
		define("VIEW_PATH",				APP_PATH."views".DIRECTORY_SEPARATOR);
		define("CONFIG_PATH",			APP_PATH."config".DIRECTORY_SEPARATOR);
		
		//载入配置文件
		
		//载入核心文件
		
		
		//确定当前所访问的平台 控制器 方法以及相应的控制器和视图目录
		define("PLATFORM",isset($_REQUEST["p"] ? $_REQUEST["p"] : "home"));
		define("CONTROLLER",isset($_REQUEST["c"] ? ucfirst($_REQUEST["c"]) : "Index")); //ucfirst使首字母变成大写
		define("ACTION",isset($_REQUEST["a"] ? $_REQUEST["a"] : "index"));
		
		define("CURR_CONTROLLER_PATH",CONTROLLER_PATH.PLATFORM.DIRECTORY_SEPARATOR);
		define("CURR_VIEW_PATH",VIEW_PATH.PLATFORM.DIRECTORY_SEPARATOR);
	}
	//2 实现自动加载功能
	private static function autoload(){
		//将load方法注册为自动加载
		spl_autoload_register(array(__CLASS__,"load"));
	}
	
	private static function load($classname){
		//此处的自动加载只加载控制器和模型
		if(substr($classname,-10)=="Controller"){
			require CURR_CONTROLLER_PATH.$classname.".class.php";
		}else if(substr($classname,-5)=="Model"){
			require MODEL_PATH.$classname.".class.php";
		}
	}
	
	//3 路由分发
	private static function dispatch(){
		//实例化控制器对象，调用方法
		$controller_name=CONTROLLER."Controller";
		$action_name=ACTION."Action";
		
		$controller=new $controller_name;
		$controller->$action_name();
	}
}

===================index.php
<?php
require "framework/core/Framework.class.php";
Framework::run();

单一入口的程序有一个特点：就是所有请求都是相对于index.php的

定义基础控制器
定义controller控制器

PHP中require文件的时候如果要写相对路径，就相对于index.php来写，因为相对路径是相对于代码执行的位置而不是定义的位置

用户表
字段			类型			功能		备注
user_id			int unsigned	主键		auto_increment
user_name		varchar(20)		姓名		not null
user_password	char(32)		密码		md5 not null
login_time		int				登录时间	
login_ip		int
login_times		int				登录错误次数
email			varchar(100)
role_id			int				所属角色

login_ip不用varchar(15) 因为int正好是4个字节 255正好是1个字节
通过ip2long方法就可以将字符串类型的ip转换成整型


当PHP程序运行时如果遇到没有定义过的类就执行注册到spl_autoload_register这个函数中的方法，并将没有定义过的类以参数的形式传入到这个方法中


<?php
header("Location:34.php");

会跳到34.php页面，立即跳转，在浏览器中访问该页面时会302重定向，再请求34.php页面

在php文件中写上setCookie("is_login","yes",time()+3600);代表给客户端一个响应，向客户端中写入is_login这样一个cookie，并设置其失效时间为一小时以后，注意此时给客户端响应的过期时间是格林威治零时区的时间，因此会比服务器设置的那个时间早8个小时


setCookie将第二个参数设置为空字符串代表删除cookie


如果访问一个已经销毁的cookie，同样会报错，例如is_login被销毁时，$_COOKIE["is_login"]会报错


存储在浏览器端的每一个cookie叫cookie变量，我们可以通过$_COOKIE["height"]=170来增加一个$_COOKIE对象下的属性，$_COOKIE对象下的属性并不一定是cookie变量，通过$_COOKIE["height"]=170设置的名为height的cookie就不是cookie变量

通过setCookie函数设置的cookie才是cookie变量

$_COOKIE数组仅仅保存当前请求浏览器所携带的cookie数据，如有以下php文件：
setCookie("name","abc");
var_dump($_COOKIE);

第一次请求时是没有name这个cookie的，第二次请求时才会有

Cookie数据默认仅仅在当前目录及其子目录有效

Cookie存在子域名概念
默认情况下test.kang.com设置的cookie在shop.kang.com下访问不到，可以通过setCookie的第5个参数设置
默认值为空字符串，表示当前域名
可以设置成顶级域名，表示在该顶级域名下的所有子域名都生效

session_start()可以开启session机制
利用对$_SESSION数组的操作，可以完成对SESSION数据的操作
增：$_SESSION["key"]=>value
删：unset
查：var_dump($_SESSION["key"])

启用session后，当服务器接收到浏览器的请求时，服务器会检查浏览器是否携带了session_id，如果存在，则以浏览器携带的session_id为当前的session标识，如果没有，则服务器重新生成一个session_id

在操作session时，使用数组变量$_SESSION，该变量在脚本结束时被自动销毁
之所以下次请求还可以用，是因为
可见，在$_SESSION被销毁之前，一定要将其数据保存起来，以便于下次再利用该数据将$_SESSION数组初始化，就是将数据保存在服务器端session数据区内，默认的数据区在服务器上是以文件的形式保存session数据的，在服务器操作系统的临时文件中
C:\Windows\Temp

详细使用
开启，支持自动开启
通过PHP配置文件php.ini设置脚本运行前自动开启，将session.auto_start值设置为1，一般不建议自动开启
如果将session.auto_start设置为1之后，再执行session_start()会触发一个提示notice级别的错误

$_SESSION数组仅支持字符串型下标

$_COOKIE只能保存字符串类型的值，而$_SESSION可以保存任何PHP数据类型的值(不包括资源类型)
当存储对象类型的值时需要在开启session之前require进来类文件，如果在php.ini中将session.auto_start设置为1，就无法在开启session之前引入类文件，因此会出错

在php.ini中可以通过session.save_path保存session数据区

session数据区的内容可能会很多，所以有可能有非常多的文件，此时需要分类存储session数据，可以通过配置session.save_path配置采用N级目录的形式来存储:session.save_path="1;e:/amp/temp" 这里面的1代表有1级子目录

SESSION-ID的形成 默认是md5

SESSION数据区(文件)的删除
unset($_SESSION["key"])

清除所有SESSION数据：$_SESSION=array()
注意不是unset($_SESSION)

unset删除的是变量 unset只是将栈中的引用和堆中的实体之间的关系切断

不管是$_SESSION=array()还是unset($_SESSION)都无法将SESSION文件删除
想要将物理文件删除必须调用session_destroy()

session_destroy()仅仅用来删除文件，即使执行了session_destroy()再var_dump($_SESSION)还是会输出相应值

完全删除SESSION
session_destroy();
$_SESSION=array();
setCookie("PHPSESSID","",time()-1);

PHPSESSID是存储在浏览器端cookie的一个key，这个名字可以在php.ini配置文件中修改：session.name=PHPSESSID
可以使用PHP内置函数来获取这个key的名字：session_name()
所以较为合适的写法应该是setCookie(session_name(),"",time()-1);


PHP与数据区存储相关的函数操作，有6个：
开始 结束 读 写 销毁 垃圾回收

function sess_open(){
	
}

function sess_close(){

}

function sess_read(){

}

function sess_write(){

}

function sess_destroy(){

}

function sess_gc(){

}

将以上自定义方法

利用PHP内置函数session_set_save_handler()存储
session_set_save_handler("sess_open","sess_close","sess_read","sess_write","sess_destroy","sess_gc")

当SESSION机制需要操作SESSION数据区时，就有用户定义的相应函数完成
此时默认机制不起作用，不以文件的形式进行存储

依据我们的SESSION存储计划，来实现以上六个函数
以SESSION的数据库存储为例完成

SESSION入库
SESSION数据表
字段		类型			作用
sess_id		varchar(32)		session_id
sess_data	text			当前session数据，序列化好的数据
expire		int				最后修改时间


create table `session` (
	sess_id varchar(32) primary key,
	sess_data text,
	expire int
) charset=utf8;
function sess_open(){
	
}

function sess_close(){
	return true;
}
//session机制开启时执行
function sess_read($sess_id){
	mysql_connect("127.0.0.1:3306","root","1234abcd");
	mysql_query("set names gbk");
	mysql_query("use `test`");
	
	$sql="select sess_data from `session` where sess_id=`$sess_id`";
	$result=mysql_query($sql);
	if($row=mysql_fetch_assoc($result)){
		return $row["sess_data"];
	}else{
		return "";
	}
}

//脚本周期结束时执行
function sess_write($sess_id,$sess_data){
	mysql_connect("127.0.0.1:3306","root","1234abcd");
	mysql_query("set names gbk");
	mysql_query("use `test`");
	
	$expires=time();
	$sql="replace into `session` values ('$sess_id','$sess_data',0)";
	//还可以写成insert into `session` values ('$sess_id','$sess_data',$expires) on duplicate key update sess_data='$sess_data';
	//或者通过判断库里有没有这条记录，再分别执行insert和update
}

//php提供的系统方法session_destroy()执行时才会触发我们自己写的sess_destroy()
//一旦销毁，sess_write就不执行了
function sess_destroy($sess_id){
	mysql_connect("127.0.0.1:3306","root","1234abcd");
	mysql_query("set names gbk");
	mysql_query("use `test`");
	
	$sql="delete from `session` where sess_id=$sess_id";
	mysql_query($sql);
}

function sess_gc($max_lifetime){
	mysql_connect("127.0.0.1:3306","root","1234abcd");
	mysql_query("set names gbk");
	mysql_query("use `test`");
	
	$expires=time();
	//数据库字段尽量出现在表达式的一边，否则不利于mysql的查询优化
	$sql="delete from `session` where expires<$expires-$max_lifetime";
	mysql_query($sql);
}
session_set_save_handler("sess_open","sess_close","sess_read","sess_write","sess_destroy","sess_gc")


php.ini中可以设置session生存时间session.gc_maxlifetime


每次开启session机制时(session_start)，有几率的执行删除垃圾的操作

可以把公共的操作例如数据库连接放在sess_start里面

session默认是以文件的方式存储的，在php.ini中session.save_handler表示，但是session.save_handler只有一个可选值，有一些扩展可以将其设置为其他选项，比较常用的选项有files user memcache

建议：如果通过session_set_save_handler自定义了session的相关方法，最好将session.save_handler改为user，可以在php中手动操作：init_set("session.save_handler","user");

应该先执行session_set_save_handler，再执行session_start，即先设置处理器，再开启session
但是有时php会自动开启session
此时需要想办法将其设置为非自动开启，除了在php.ini中配置以外还可以在.htaccess文件中配置：
php_flag session.auto_start 0

session面试题
session和cookie的联系，都是会话技术
session和cookie的区别（从安全性 请求传输的数据量 对数据类型的支持 大小的限制 永久性保存的问题 角度说明），session位于服务器端，cookie位于客户端


如何持久化session
SESSIONID的有效期session.cookie_lifetime
SESSION数据区的有效期session.gc_maxlifetime

cookie禁用的话可以使用session吗？
可以，只要找到代替cookie传递sessionID的方式即可
利用get或post方式即可
在php.ini配置session.use_only_cookies=1，该参数设置为1代表不仅仅使用cookie传递

session.use_trans_sid=1;是否自动传输sessionID
如果按照session.use_trans_sid=1配置，php会将所有的html代码中的链接地址部分增加上PHPSESSIONID参数




