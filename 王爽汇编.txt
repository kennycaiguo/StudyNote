汇编语言由汇编指令 伪指令 其他符号3类指令组成，核心是汇编指令

CPU进行数据的读写必须和外部器件(芯片)进行以下3类信息的交互
1、存储单元地址
2、器件的选择 读或写命令
3、读或写的数据

CPU由运算器 控制器 寄存器(CPU工作原理)等器件构成
CPU中，运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件工作
内部总线连接各种器件，在它们之间进行数据传输

寄存器是CPU中程序员可以用指令读写的部件
程序员通过改变各种寄存器中的内容来实现对CPU的控制

不同的CPU寄存器的个数机构是不同的，8086CPU有14个寄存器：
AX BX CX DX SI DI SP BP IP CS SS DS ES PSW

8086的CPU都是16位的，可以存放两个字节

通用寄存器：AX BX CX DX 存放一般性数据

16位机的具体含义是：
运算器一次最多可以处理16位数据
寄存器的最大宽度为16位
寄存器和运算器之间的通路为16位

也就是在8086CPU内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位的

从8086CPU内部来看，如果将地址从内部简单地发出，那么它只能送出16位地址，表现出的寻址能力只有64KB，不过8086CPU没有这样做，而是把地址总线扩充成了20位，这样就有了1MB寻址能力

32根地址总线的寻址能力：2^2 * 2^10 * 2^10 * 2^10 = 4GB

8086CPU内部采用两个16位地址合成的方法来形成一个20位的物理地址，这两个16位地址分别叫做段地址和偏移地址

物理地址 = 段地址 * 16 + 偏移地址

8086CPU中有4个段寄存器：CS DS SS ES

8086CPU访问内存时由这4个段寄存器提供内存单元的段地址

CS和IP指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器

任意时刻，设CS中内容为M，IP中内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行

8086CPU工作过程可以简要描述如下：
从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器
IP=IP+所读取指令的长度，从而指向下一条指令
执行指令，转到步骤1，重复这个过程

8086CPU加电启动或复位后(即CPU刚开始工作时)，CS和IP被设置为CS=FFFFH，IP=0000H，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

内存中指令和数据没有任何区别，都是二进制信息，CPU工作的时候把有的信息看成指令，有的信息看成数据。CPU如何区分指令和数据呢？实际上CPU是将CS:IP指向的内存单元中的内容看做指令。

mov指令是不可以修改CS IP的值的

能够改变CS IP的内容的指令被统称为转移指令(以后深入研究)，现在先简单了解一个指令：
jmp指令
jmp 2AE3:3 执行后CS=2AE3H IP=0003H CPU将从2AE33H处读取指令

如果仅仅想修改IP的内容，可以用形如jmp "某一合法寄存器" 的指令来完成:
jmp ax 意思是将IP中的值修改为寄存器ax中的值

第三章
字单元即存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

我们将起始地址为N的字单元简称为N地址字单元

8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。比如我们要读取10000H单元的内容，可以用如下程序段进行：
mov bx,1000H
mov ds,bx
mov al,[0]
这三条指令将10000H(1000:H)中的数据读到al中

指令执行时，8086CPU会自动取ds中的数据为内存单元的段地址，因此mov a1,[0]在执行时，CPU将从ds中取到段地址，再和[0]偏移地址合并起来在内存中定位到10000，将其数据放入al寄存器中

注：8086CPU不支持将数据直接送入段寄存器的操作，即不能把1000H这样的数据直接送入ds寄存器，即不能写mov ds,1000H这样的指令，因此只能通过bx段寄存器中转一下

8086CPU是16位结构，有16根数据线

有mov ds,ax 就会有mov ax,ds

有mov [0],ax 就会有mov [0],cs

mov ds,[0]也是可以的

段寄存器不可以用在算术指令中，因此下列指令都不正确
add ds,ax
add ax,ds
sub ds,ax
sub ax,ds

将内存中的字型数据读取到寄存器中
mov ax,123BH
mov ds,ax
mov ax,0
add ax,[0] //将123B0H和123B1H两个字节中的数据读到寄存器ax中

在基于8086CPU编程的时候可以将一段内存当成栈来使用
push ax //将ax中的数据送入栈中

pop ax //将内存中的数据从栈顶取出放到ax寄存器中

8086CPU中，段寄存器SS和寄存器SP分别存放栈顶的段地址和偏移地址
任意时刻，SS:SP指向栈顶元素
push和pop指令执行时，CPU从SS和SP中得到栈顶的地址

push ax的执行，由以下两步完成
SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

push入栈时，栈顶从高地址向低地址方向增长
pop和push正好相反

push ss //将ss中的数据放入栈顶
pop ss //将栈顶数据弹出存到ss寄存器中

mov ax,1000H
mov ds,ax
push [0] //将1000:0中的数据压入栈顶
pop [2] //从栈顶取出数据，并送到1000:2处

push pop操作改的只是SP，因此，栈顶的变化范围最大为0-FFFFH

第四章

第五章
loop指令的格式是：loop 标号
CPU执行loop指令时，分两步：
1、(cx) = (cx) - 1
2、判断cx中的值，不为0则转移至标号处执行程序，如果为0则向下执行
从上面的描述中可以看出，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx中存放循环次数
计算2^12
assume cs:code
code segment
	mov ax,2
	mov cx,11
	
s:	add ax,ax ;s是一个标号，它实际上标识了一个地址，这个地址处有一条指令add ax,ax
	loop s ;CPU执行loop s的时候首先(cx) = (cx) - 1 再判断cx中的值，如果(cx)不为0则转至符号s所标识的地址处执行(这里的指令是add ax,ax)，如果为0则执行下一条指令
	mov ax 4c00h
	int 21h
code ends
end














































