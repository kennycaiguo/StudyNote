BS模型利用HTTP HTTPS协议
CS模型利用TCP/IP协议

BS模型或CS模型的抽象
#ifndef _SOCKETCLINET_H
#endif _SOCKETCLINET_H

#ifdef __cplusplus //如果用了C++的编译器，用C语言的规范来引用
extern "C" {
#endif

//socket客户端环境初始化
int socketclient_init(void** handle);
//socket客户端报文发送
int socketclient_send(void* handle, unsigned char* buf, int buflen);
//socket客户端报文接收
int socketclient_recv(void* handle, unsigned char* buf, int buflen);
//socket客户端环境释放
int socketclient_destroy(void *hanlde);

//第二套API函数
//socket客户端环境初始化
int socketclient_init2(void** handle);
//socket客户端报文发送
int socketclient_send2(void* handle, unsigned char* buf, int buflen);
//socket客户端报文接收
int socketclient_recv2(void* handle, unsigned char** buf, int* buflen);
//socket客户端环境释放
int socketclient_destroy2(void** hanlde);

#ifdef __cplusplus
}
#endif

#endif

//技术点分析
1级指针
2级指针
void** handle类型封装的概念 业务模型封装的概念


数组做函数参数的退化问题 数组做函数参数时会退化为一个指针
正确的做法是把数组内存首地址和数组的有效长度给被调函数
//void printArray(int a[6],int len)
//void printArray(int a[],int len){
void printArray(int *a,int len){
	int i;
	int len2=0;
	le2=sizeof(a)/sizeof(a[0]);//1
	//在这里，实参的a和形参的a数据类型是不一样的，这里的实参是数组类型，而形参是指针类型
	//因此实参中数组的长度是sizeof(a[0])*sizeof(a)，而形参中指针的长度是4
	//传进来的形参的形式不管是int a[] 还是int a[6] 还是int *a C编译器都会把它当作指针类型
	//编译器之所以这样做是因为如果形参当中的a如果也是数组类型的话，就相当于将实参中的数组中所有的数据都拷贝一份到形参中，无形之中降低了C语言编译期的效率
	//而通过指针类型的形参操作数据是C语言的特点
	//形参写在函数里面和写在函数定义的括号里面是一样的，写在函数定义的括号里面拥有对外的属性
	
	for(i=0;i<len;i++){
		printf("%d",a[i]);
	}
}
void main(){
	int a[]={1,2,3,4,5,6};
	int len=sizeof(a)/sizeof(a[0]);
	
	printArray(a,len);
}

内存四区专题讲座
数据类型是为了方便的表示现实中的事物

类型相同的数据有相同的表示形式、存储格式以及相关的操作

数据类型可以理解为创建对象的模具，是固定内存大小的别名
int a;//告诉C编译期分配4个字节的内存
int b[10];//告诉C编译期分配40个字节的内存

printf("%d",b);//1244972
printf("%d",b+1);//1244976
printf("%d",&b);//1244972
printf("%d",&b+1);//1245012

//b+1 &b+1 结果不一样 b &b所代表的数据类型不一样
//b是数组首元素的地址
//&b是整个数组的地址

//b &b 数组数据类型

//区分数组类型 数组指针 数组类型和数组指针类型的关系 下节课才讲

printf("%d",sizeof(b));//40
printf("%d",sizeof(a));//4

//给数据类型起别名
struct Teacher{
	char name[64];
	int age;
}Teacher;
void main(){
	int a;
	int b[10];
	
	struct Teacher t1; //通过struct Teacher定义的类型在定义变量时必须通过struct Teacher定义，即struct不可以省略
	t1.age=31;
	
	printf("hello...\n");
}


typedef struct Teacher{
	char name[64];
	int age;
}Teacher;
void main(){
	int a;
	int b[10];
	
	Teacher t1; //通过typedef struct Teacher定义的类型在定义变量时可以省略掉struct
	t1.age=31;
	
	printf("hello...\n");
}

typedef还可以对基本类型重命名
typedef int u32;

//数据类型的封装
void 字面意思是无类型
void * 无类型指针
void * 可以指向任何类型的数据

用法1：数据类型的封装
int initHardEnv(void** handle);
void* memcpy(void* dest,const void* src,size_t len);
void* memset(void* buffer,int c,size_t num);

用法2：void修饰函数返回值和参数，仅表示无
如果函数没有返回值，那么应该将其声明为void型
如果函数没有参数，应该将其声明为void
int function(void){
	return 1;
}

void指针的意义
C语言规定只有相同类型的指针才可以相互赋值
void*指针作为左值用于接收任意类型的指针
void*指针作为右值赋值给其他指针时需要强制类型转换
int* p1=NULL;
char* p2=(char*)malloc(sizeof(char)*20); //malloc返回的是一个void*类型的指针

不存在void类型的变量
C语言没有定义void究竟是多大内存的别名

思考1：
C一维数组 二维数组有数据类型吗？int array[10];
若有，数组类型又如何表达？如何定义？
若没有，请说明原因

思考2：
C语言中，函数可以看作一种数据类型吗？
若可以，请说明原因，并进一步思考：函数这种数据类型能再重定义吗？
若不可以，请说明原因
//实际上函数也是一种数据类型，在5天之后讲回调函数时会提到

变量本质分析
变量概念：既可以读又可以写的内存对象称为变量，若一旦初始化后不能修改的对象则称常量
变量本质：程序通过变量来申请和命名内存空间int a=0;
通过变量名可以访问一个或一段内存空间
(一段连续)内存空间的别名(是一个门牌号)
修改变量有几种方法？
	直接改
	间接改 内存有地址编号，拿到变量对应的地址编号也可以修改变量的值
	内存空间可以再取给别名吗？

数据类型和变量的关系
	通过数据类型定义变量

总结及思考题
	对内存，可读可写
	通过变量往内存读写数据
	不是向变量读写数据，而是向变量所代表的内存空间中写数据
	问：变量跑哪去了？
	思考1：变量三要素(名称 大小 作用域)，变量生命周期？
	思考2：C++编译器是如何管理函数的？包括：
		1 函数
		2 变量之间的关系的？
	重要话题：
		内存四区模型
		函数调用模型

int a;
int b;
char* p;
a=10;

printf("%d",&a); //1245024

//直接操纵内存地址
*((int*)1245024)=200; //让编译器以int*的方式处理1245024这块内存，外面的*意思是拿到这块内存，然后再将200放到这块内存中
==========================
char *p;
{
	p=1245024;//将门牌号赋给指针变量p
	*p=300;//*p代表拿到1245045这块内存空间，然后将300放入这块内存空间中
}

操作系统把C代码分成栈 堆 代码区 全局区
栈：由编译器自动分配释放，存放函数的参数值，局部变量的值
堆：由程序员分配释放
全局区(静态区)：全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，该区域在程序结束后由操作系统释放
常量区：字符串常量和其他常量的存储位置，程序结束后由操作系统释放
程序代码区：存放函数体的二进制代码

//静态存储区理解
char* getStr1(){
	char* p="abcdefg1";
	return p1;
}
char* getStr2(){
	char* p="abcdefg2";
}
void main(){
	char* p1=NULL;
	char* p2=NULL;
	p1=getStr1();
	p2=getStr2();
	//打印p1 p2所指向内存空间的数据
	printf("%s",p1);//abcdefg1
	printf("%s",p2);//abcdefg2
	printf("%d",p1);//4282320
	printf("%d",p2);//4282456
	//p1和p2的地址不相同 两个函数返回值不一样时，词法分析后的结果有两个
}

char* getStr1(){
	char* p="abcdefg2";
	return p1;
}
char* getStr2(){
	char* p="abcdefg2";
}
void main(){
	char* p1=NULL;
	char* p2=NULL;
	p1=getStr1();
	p2=getStr2();
	//打印p1 p2所指向内存空间的数据
	printf("%s",p1);//abcdefg1
	printf("%s",p2);//abcdefg2
	printf("%d",p1);//4282320
	printf("%d",p2);//4282320
	//p1和p2的地址不同 两个函数返回值一样时，这是因为词法分析后的结果只有一个
}

=================堆区
char *getMem(int num){
	char *p1=NULL;
	p1=(char*)malloc(sizeof(char)*num);
	if(p1==NULL){
		return NULL;
	}
	return p1;
}
void main(){
	char* tmp=NULL;
	tmp=getMem(10);
	if(tmp==NULL){
		return;
	}
	strcpy(tmp,"111222");//往tmp指向的内存空间拷数据
	printf("%s",tmp);//111222
}

==================栈区
char *getMem2(){
	char buf[64];//临时变量，栈区存放
	strcpy(buf,"123456789");
	printf("%s",buf);//12345678
	return buf;//这里的return是把内存块的首地址返回给tmp了
}
void main(){
	char* tmp=NULL;
	tmp=getMem2();//返回的buf已经被释放了，没法引用，这时程序没有当机已经很不错了
	printf("%s",tmp);//什么都没有
}

安装VAssistX，可以设置一些快速生成代码的快捷键
===================写程序测试栈的生长方式，是开口向上还是开口向上
void main(){
	int a;
	int b;
	printf("%d",&a);//1245044
	printf("%d",&b);//1245048
	//有时&a比&b大，有时&a比&b小，后者是更多的情况
	
	char buf[128];//不管栈开口向上还是向下，buf的内存地址永远是向上的
	//栈是静态编译 在编译器buf所代表的内存空间的标号就定了
}

如果在main函数中调用了函数fa，fa中开辟的栈内存在main中不可以访问，fa中开辟的堆内存在main中可以访问
局部函数中在全局区定义的常量，如"abcdefg"也可以在main函数里面调用

每个应用程序都有一个内存四区


指针变量和它所指向的内存块是两个不同的概念
含义1：给p赋值p=0x1111，只会改变指针变量值，不会改变所指的内容p=p+1 p++
含义2：给*p赋值*p='a'，不会改变指针变量的值，只会改变所指的内存块的值
含义3：左边*p表示给内存赋值 右边*p表示取值
含义4：左边 char* p1
含义5：想要通过指针修改内存中的值时一定要保证所指的内存块能修改

char* getStr(){
	char* tmp=NULL;
	tmp="abcdefg";
	return tmp;
}
void main(){
	char *p=getStr();
	*(p+2)='r';//常量区是不可以修改的，直接会报错
}

指针也是一种数据类型，是指它指向的内存空间的数据类型
int getABC(char *p1);
int getABC(char **p2);
int getABC(char ***p3);
int getABC(char (*p4[30]));
int getABC(char p5[10][30]);
指针做函数参数 形参有多级指针的时候
站在编译器角度，只需要分配4个字节的内存
当我们使用内存的时候，我们才关心指针所指向的内存，是一维的还是二维的
含义1：指针步长根据所指内存空间类型来定

野指针案例
char *p1=(char *)malloc(100);
strcpy(p1,"111222");
if(p1!=NULL){
	free(p1);
	p1=NULL;//这一步一定要加，否则p1就成了野指针，因为我们free掉p1的时候是将其对空间的内存释放了，但是p1这个变量里面还存着某个地址，所以需要手动清空它
	//如果不释放的话，当后面的代码再用if判断p1!=NULL从而去判断是否free(p1)时，依然返回true，此时如果再次调用一次free(p1)的话，就是要释放一块没有被引用的地址，肯定会出问题
	
	//指针变量和它所指向的内存块是两个不同的概念，释放了指针所指的内存空间，但是指针变量本身没有重置，造成释放的时候if(p!=NULL)
	
	//避免方法：定义指针的时候初始化成NULL，释放指针所指的内存空间后把指针重置为NULL
}


void main(){
	char buf[128]; //在栈上分配内存
	int i;
	int j=0;
	
	char* p1=NULL;
	char* p2=NULL; //在堆上分配内存
	
	p1=&buf[0];
	p1=&buf[1];
	p1=&buf[2];
	
	p2=(char*)malloc(100);
	
	for(i=0;i<10;i++){
		p1=p2+i; //p1不断的指向p2所指向的堆内存的各个字节，通过这个例子我们可以得出结论：可以通过开辟堆内存空间来让多个函数共享这一块内存
	}
}
---------------------------------------------向null地址copy数据时报错的问题
void main(){
	char* p1=NULL;//定义p1是一个地址 初始化让p1指向了0x0000这个地址
	
	strcpy(p1,"abcdefg");//将"abcdefg"复制到p1所指向的0x0000地址里面，但是0x0000操作系统正在使用，所以报0x0000地址访问冲突的bug
}
============================================================间接赋值

间接赋值从0级到1级指针
int getFileLen(int *p){
	*p=40;
}
//将变量b写在参数中和写在函数体里面没有任何区别，只不过写在参数中具有对外的属性而已，对外属性也就是可以在函数调用的时候为其赋值
int getFileLen3(int b){
	b=100;
}
void main(){
	int a=10;
	int *p=NULL;
	
	a=20;//直接修改
	p=&a;
	*p=30;//p的值是a的地址，*就是一把钥匙，通过地址找到了一块内存空间 间接的修改了a的值
}




间接赋值从1级指针到2级指针
void main(){
	char *p1=NULL;
	char **p2=NULL;

	p1=0x11;
	p2=0x22;

	//直接修改p1的值
	p1=0x111;

	p2=&p1;

	//间接修改p1的值 p2里面就是p1的地址
	*p2=100;
}




//将上面的间接修改抽成函数
void getMem(char **p2){
	*p2=200;//间接赋值 p2是p1的地址
}
void main(){
	char *p1=NULL;
	char **p2=NULL;

	p2=&p1;
	getMem(&p1);//一级指针p1再取地址就是二级指针
}

//设想一下如果通过一级指针来间接修改指针的话
void getMem2(char *p1){
	p1=800; //这里改的只是p1这个变量本身的值，并没有改变p1指向的内存空间的值，因此getMem2执行完后p1的内存被回收，main函数里面的p1指向的内存里面存储的值该是多少还是多少
}
void main(){
	char *p1=NULL;
	getMem2(p1);//不会成功 因为函数里面的形参在函数运行结束后被回收了
}




//综上所述：间接赋值是指针存在的最大意义
//二级指针的应用：给p1 p2初始化，使其指向对应的内存空间
void getMem3(char **myp1,int *mylen1,char **myp2,int *mylen2){
	int ret=0;
	char *tmp1,*tmp2;	
	
	tmp1=(char *)malloc(100);
	strcpy(tmp1,"112233");
	*mylen1=strlen(tmp1);
	*myp1=tmp1;
	
	tmp2=(char *)malloc(100);
	strcpy(tmp2,"aabbcc");
	*mylen2=strlen(tmp2);
	*myp2=tmp2;
	
	return ret;
}
void main(){
	char *p1=NULL;
	int len1=0;
	char *p2=NULL;
	int len2=0;
	getMem3(&p1,&len1,&p2,&len2);
}

可以通过指针间接赋值的3个条件
int main(){
	//条件1 定义了两个变量
	int a=10;
	int *p=NULL;
	//条件2 建立了关联
	p=&a;
	//条件3 *p
	*p=40;
}

间接赋值的应用场景
void main(){
	//第一种 1 2 3这3个条件写在一个函数中
	//第二种 12 写在一个函数里面 3单独写在另外一个函数里面 =>函数调用
	//第三种 1单独写 23写在一块儿 =>抛砖 在C++里面会有，以后会讲
	
	//第一种
	char from[128];
	char to[128]={0};
	char *p1=from;
	char *p2=to;
	strcpy(buf,"12345678");
	while(*p1!='\0'){
		*p2=*p1;
		p2++;
		p1++;
	}
	printf("%s",to);
}

间接赋值推论
用一级指针形参间接修改零级指针(实参)的值
用二级指针形参间接修改一级指针(实参)的值

铁律3：理解指针必须和内存四区概念相结合
主调函数可把堆区 栈区 全局数据内存地址传给被调函数
被调函数只能返回堆区 全局数据区
指针做函数参数，是有输入(在主调用函数中分配内存，给被调用函数使用)和输出(和输入相反)特性的
企业开发中经常看到形参中这样的注释
int getMem(char** myp1/*out*/, int* mylen1/*out*/, char** myp2/*out*/, int* mylen2/*out*/); //注释中的out就是为了标明myp1是输出的指针

铁律4 应用指针必须和函数调用相结合(指针做函数参数)见图
一级指针做输入
	//通常用于将数组或字符串作为参数传进被调函数中进行处理
	int showbuf(char* p)
	int showArray(int* array, int iNum)
一级指针做输出
	int getLen(char* pFileName, int* pFileLen)
二级指针做输入
	int main(int arc, char* arg[])
	int showMatrix(int[3][4], int iLine)
二级指针做输出
	int getData(char** data, int* dataLen);
	int getData_Free(void* data);
	int getData_Free(void** data); //避免野指针
三级指针做输出
	int getFileAllLine(char*** content, int* pLine);
	int getFileAllLine_Free(char*** content, int* pLine);

字符串基本操作
C语言的字符串是以0结尾的字符串
C语言中没有字符串类型 通过字符数组来模拟字符串
字符串的内存分配 可以在堆上 栈上 全局区 很重要!!!
void main(){
	//字符数组初始化
	//不指定长度的 C编译器会自动求出元素的个数
	char buf1[]={'a','b','c','d'};//没有以0结尾 不是字符串 只算是字符数组
	//指定长度
	char buf2[100]={'a','a','a','a'};//没有赋值的都是0
	//char buf3[2]={'a','a','a','a'};//如果初始化的个数大于长度 编译会报错
	
	//字符串来初始化字符数组
	char buf3[]="abcd";//buf3作为字符数组的长度是5，后面会多一个0
	//buf3作为字符串长度是4
	int len=strlen(buf3);//4 得到的是字符串的长度
	int len2=sizeof(buf3);//5 得到的是数组的长度
	//数组是一种数据类型，本质是固定大小内存块的别名
}

void main(){
	int i=0;
	char *p=NULL;
	char buf5[128]="abcdefg";//这个字符串是在全局区存储的
	for(i=0;i<strlen(buf5);i++){
		printf("%c",buf5[i]);
	}
	p=buf5;//buf5代表数组首元素的地址
	for(i=0;i<strlen(buf5);i++){
		printf("%c",*(p+i));
	}
}

//[]和*来访问数组元素没区别
buf5[i] ==> buf5[0+i] ==> *(buf5+i)

buf5是一个常量指针 设计成这样是要保证buf5所指向的内存空间安全释放

字符串一级指针内存模型
void main(){
	char buf[20] = "aaaa"; //为变量buf分配了20个字节大小的内存 字符串"aaaa"是放在了全局区
	char buf2[] = "bbbb"; //为变量buf2分配了5个字节大小的内存 字符串"bbbb"也是放在了全局区
	char *p1 = "111111"; //为变量p1分配了4字节大小内存 字符串"111111"也是放在了全局区
	char *p2 = malloc(100); //为变量p2分配了4字节大小内存 从堆中申请了100个字节内存，让p2指向该内存
	strcpy(p2, "3333"); //将全局区的"3333"拷贝到p2所指向的堆内存中
}

字符串copy函数技术推演
//原来的做法
void main(){
	char a[] = "i am a student";
	char b[100];
	int i;
	
	for(i = 0;*(a + i) != '\0';i++){
		*(b + i) = *(a + i);
	}
	
	//此时字符串a末尾的\0并没有拷贝到b中，因此需要手动拷贝
	b[i] = '\0';
}

//现在的做法
void main(){
	char* from = "aaaa";
	char to[100];
	copy_str(from, to);
}

void copy_str(char* from, char* to){
	for(;*from != '\0'; from++,to++){
		*to = *from;
	}
	*to = '\0';
}
//优化后
void copy_str2(char* from, char* to){
	for(;*from != '\0';){
		//先*to = *from 再to++,from++
		*to++ = *from++;
	}
	*to = '\0';
}
//再次优化
void copy_str3(char* from, char* to){
	while((*to = *from) != '\0'){
		from++;
		to++;
	}
}
//再次优化
void copy_str4(char* from, char* to){
	while((*to++ = *from++) != '\0');
}
//再次优化
void copy_str5(char* from, char* to){
	//0是假
	while(*to++ = *from++);
}

//最好应该判断一下from和to指向的内存是否合法
void copy_str6(char* from, char* to){
	if(to == NULL || from == NULL){
		return -1;
	}
	while(*to++ = *from++);
}

此时如果在main函数中想printf一下from字符串，发现打印不出来了，这是因为from已经指向'\0'了，因此打印不出来，应该在被调用函数中开两个变量把from和to缓冲一下
void copy_str4(char* from, char* to){
	char* tmpfrom = from;
	char* tmpto = to;
	if(tmpfrom == NULL || tmpto == NULL){
		return -1;
	}
	while(*to++ = *from++);
}
上面的案例说明了我们不能轻易改变形参的值，要通过缓冲变量把形参接过来

指针初始化时如果没有合适的值必须初始化为NULL，指针在用完后也要赋值NULL

项目开发中的字符串模型
strstr-whiledowhile模型
void main(){
	int ncount = 0;
	char* p = "abcd111122abcd33333abcdabcd"; //求字符串abcd出现的次数
	do{
		// 返回字符串p中的字串"abcd"的位置
		p = strstr(p, "abcd");
		if(p != NULL){
			ncount++;
			p += strlen("abcd");
		}else{
			break;
		}
	}while(*p != '\0');
}

//将上述需求封装到函数中(以下代码为自己所写)
void main(){
	char* str = "abcd111122abcd33333abcdabcd";
	char* substr = "abcd";
	int len = 0;
	
	get_substr_times(str, substr, &len);
}
int get_substr_times(char* str, char* substr, int* times){
	char* tmp_str = str;
	char* tmp_substr = substr;
	char* p = NULL;
	if(tmp_str == NULL || tmp_substr == NULL){
		return -1;
	}
	while((p = strstr(tmp_str, tmp_substr)) != NULL){
		*times++;
		p += sizeof(tmp_substr);
		if(*p == '\0'){
			break;
		}
	}
	
	return 0;
}

两头堵模型：两个指针，一个指向字符串开头，另一个指向字符串结尾
求非空格的长度
void main(){
	char *p = "    abcdefg    ";
	int i,j = 0;
	int ncount;
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	ncount = j - i + 1;
}

封装到函数中：
void getCount(char* str, int* pCount){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	*pCount = j - i + 1;
}

//去除字符串前后空格
void trimSpace(char* str,char* newStr){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	strncpy(newStr, str, j - i + 1);
	newStr[j - i + 1] = '\0';
}
//优化：不传newStr
void main(){
	// 由于传进来的字符串"    abcdefg    "存储在全局区，是不可以修改的，因此str在修改的时候报错
	//char* str = "    abcdefg    ";
	// 因此要将内存分配在临时区
	char buf[1024] = "    abcdefg    ";
	trimSpace(str);
}
void trimSpace(char* str){
	char *p = str;
	int i,j = 0;
	if(str == NULL || pCount == NULL){
		return -1;
	}
	
	i = 0;
	j = strlen(p) - 1;
	
	while(isspace(p[i]) && p[i] != '\0'){
		i++;
	}
	
	while(isspace(p[j]) && p[j] != '\0'){
		j--;
	}
	// 由于传进来的字符串"    abcdefg    "存储在全局区，是不可以修改的，因此str在修改的时候报错
	strncpy(str, str + i, j - i + 1);
	newStr[j - i + 1] = '\0';
}

//逆序模型
void main(){
	char buf[] = "abcdefg";
	int length = strlen(buf);
	char* p1 = buf;
	char* p2 = buf + length - 1;
	
	while(p1 < p2){
		char c = *p1;
		*p1 = *p2;
		*p2 = c;
		++p1;
		--p2;
	}
}

//抽到函数中
void main(){
	char buf[] = "abcdefg";
	reverse(buf);
}
int reverse(char* buf){
	// 要先定义
	int length;
	char* p1;
	char* p2;
	
	// 再使用
	length = strlen(buf);
	p1 = buf;
	p2 = buf + length - 1;
	
	while(p1 < p2){
		char c = *p1;
		*p1 = *p2;
		*p2 = c;
		++p1;
		--p2;
	}
}

//翻转字符串的另一种方案：递归
//栈模型是先入后出，因此可以先让各个字符依次入栈，再让各个字符依次出栈即可
//可以将逆序的结果存入全局变量

//递归的重点：
//参数的入栈模型
//函数嵌套调用返回流程
char global_buf[100];
void main(){
	char buf[] = "abcdefg";
	memset(global_buf, 0, sizeof(global_buf));
	reverse(buf);
}
void reverse(char* buf){
	if(buf == NULL){
		return;
	}
	//递归结束的条件
	if(*buf == '\0'){
		return;
	}
	reverse(p + 1);
	//printf("%c", *p);
	//存到全局变量global_buf中
	//strncpy(global_buf, p, 1); //把p所指向的字符串处的后面1个字符拷贝到global_buf中去
	strncat(global_buf, p, 1); //把p所指向的字符串处的后面1个字符拼接到global_buf后面去
}

全局变量在多线程中会遇到问题，因此我们要考虑如何用递归修改一个局部变量
void main(){
	char buf[];
	char mybuf[1024];
	
	buf = "abcdefg";
	mybuf[1024] = {0};
	
	reverse(buf, mybuf);
}
void reverse(char* buf, char* bufresult){
	if(buf == NULL){
		return;
	}
	//递归结束的条件
	if(*buf == '\0'){
		return;
	}
	reverse(p + 1, bufresult);
	strncat(bufresult, p, 1);
}

读取键值对
int getKeyByValue(char* keyvaluebuf, char* keybuf, char* valuebuf){
	int ret = 0;
	char* p = NULL;
	
	if(keyvaluebuf == NULL || keybuf == NULL || valuebuf == NULL){
		return -1;
	}
	
	//1、查找keybuf是不是在母串中
	p = keyvaluebuf; //初始化辅助指针变量
	p = strstr(p, keybuf);
	if(p == NULL){
		return -1;
	}
	//让辅助指针变量重新到达下一次检索的条件
	p = p + strlen(keybuf);
	//2、看有没有=号
	p = strstr(p, "=");
	if(p == NULL){
		return -1;
	}
	//让辅助指针变量重新到达下一次检索的条件
	p = p + strlen("=");
	
	//3、在=号后面去除空格
	ret = trimSpace(p, valuebuf);
	if(ret != 0){
		printf("%d", ret);
		return ret;
	}
	return ret;
}
int main(){
	int ret = 0;
	char buf[1024] = {0};
	char* keyandvalue = "key2 = value2
						 key3 = value3
						 key4 = value4";
	char* key2 = "key2";
	
	ret = getKeyByValue(keyandvalue, key2, buf);
	if(ret != 0){
		printf(ret);
	}
}

一级指针容易犯错误的地方：
1、初始化及在调用时所做的判断
char* buf = NULL;		//这是对buf本身，即指针所处的内存本身进行初始化
char* buf = "abc";		//这是对buf指向的内存空间进行初始化，buf将指向全局区的一块空间
char buf[1024] = {0};	//这是对buf指向的内存空间进行初始化，buf将指向栈区的一块空间
指针传入函数后在使用之前需要先判断其是否合法，需要先判断指针是否为NULL，而不是指针指向的内存空间的值是否为NULL，即以下写法为错误写法：
if(*buf == NULL){
	//...
}
如果buf传进来的是NULL，*NULL直接宕机

2、越界
char* buf[3] = "abc"; //错误
char* buf[4] = "abc"; //正确

二级指针
//求文件中两段话的长度
int getMem(char** p1, int* len1, char** p2, int* len2){
	char* tmp1 = NULL;
	char* tmp2 = NULL;
	tmp1 = (char*)malloc(100);
	if(tmp1 == NULL){
		return -1;
	}
	strcpy(tmp1, "abcdefg");
	*len1 = strlen(tmp1);
	*p1 = tmp1;
	
	tmp2 = (char*)malloc(100);
	if(tmp2 == NULL){
		return -2;
	}
	strcpy(tmp2, "abcdefg");
	*len2 = strlen(tmp1);
	*p2 = tmp2;

	return 0;
}
//为了避免野指针的出现，传入二级指针时释放内存空间后还要把二级指针指向的地址空间的值赋值为NULL
int getMemFree(char** p1){
	char* tmp = NULL;
	if(p1 == NULL){
		return -1;
	}
	tmp = *p1;
	free(*p1);
	*p1 = NULL; //释放完指针变量所指的内存空间之后再将实参修改成NULL
	return 0;
}
//传入一级指针时只需要释放内存空间即可
int getMemFree0(char* p1){
	if(p1 == NULL){
		return -1;
	}
	free(p1);
	//p1 = NULL;	//在此将p1置为NULL没有任何意义，因为p1是一个形参，p1仅仅是栈空间的一个变量，函数调用结束之后p1内存被回收
	return 0;
}
int main(){
	char* p1 = NULL;
	int len1 = 0;
	
	char* p2 = NULL;
	int len2 = 0;
	
	getMem(&p1, &len1, &p2, &len2);
	
	getMemFree(&p1);
	getMemFree(&p2);
	
	//如果采用传入一级指针的方式释放：
	//getMemFree0(p1); //在被调用函数中 把p1所指向的内存释放掉，但是实参p1不能被修改成NULL，因此p1依然是野指针
	//getMemFree0(p2);
	//这样释放完后p1 p2依然是野指针
}

总结：
指针做输出时由被调函数分配内存
指针做输入时由主调函数分配内存


二级指针做输入第一种模型
void main(){
	int i = 0;
	int j = 0;
	int num = 0;
	char* tmp = NULL;

	// 数组 数组中的内一个元素装的是指针 指针数组
	// 注意与char* myArray的区分，char* myArray中的myArray变量存储的是一个字符串的首地址
	// char* myArray[]中的myArray变量存储多个字符串首地址的集合
	char* myArray[] = {"aaa", "ccc", "bbb"};
	
	//打印
	num = sizeof(myArray) / sizeof(myArray[0]);
	for(i = 0; i < num; i++){
		// 以下两种方式打印效果一样
		printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
	
	//排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(myArray[i], myArray[j])){
				// 注意：交换的是数组元素，也就是交换指针的值
				tmp = myArray[i];
				myArray[i] = myArray[j];
				myArray[j] = tmp;			
			}
		}
	}
}

//将上述打印和排序封装成函数
void printMyArray(char** myArray, int num){
	int i = 0;
	for(i = 0; i < num; i++){
		// 以下两种方式打印效果一样
		printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
}

void sortMyArray(char** myArray, int num){
	int i = 0;
	int j = 0;
	char* tmp = NULL;
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(myArray[i], myArray[j])){
				// 注意：交换的是数组元素，也就是交换指针的值，并不是改变指针指向的值
				tmp = myArray[i];
				myArray[i] = myArray[j];
				myArray[j] = tmp;			
			}
		}
	}
}
void main(){
	int num = 0;
	char* myArray[] = {"aaa", "ccc", "bbb"};
	
	num = sizeof(myArray) / sizeof(myArray[0]);
	
	printMyArray(myArray, num);
	
	sortMyArray(myArray, num);
}

二级指针做输入第二种模型
void main(){
	int i = 0;
	int j = 0;
	int num = 4;
	char tmpBuf[30];
	char myBuf[30];
	char myArray[10][30] = {"aaa", "bbb", "ccc", "ddd"};
	
	// 打印
	for(i = 0; i < num; i++){
		printf("%s", myArray[i]);
	}
	
	//排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(myArray[i], myArray[j]) > 0){
				strcpy(tmpBuf, myArray[i]); //交换的是内存块
				strcpy(myArray[i], myArray[j]);
				strcpy(myArray[j], tmpBuf);
			}
		}
	}
}
// 封装到函数中：
void printMyArray_err(char** myArray, int num){
	int i = 0;
	for(i = 0; i < num; i++){
		printf("%s", *(myArray + i));
	}
}
void printMyArray(char myArray[10][30], int num){
	int i = 0;
	for(i = 0; i < num; i++){
		printf("%s", *(myArray + i));
	}
}
// 交换的是内存块，不是指针的指向
void sortMyArray(char myArray[10][30], int num){
	int i = 0;
	int j = 0;
	char tmpBuf[30];
	
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(myArray[i], myArray[j]) > 0){
				strcpy(tmpBuf, myArray[i]); //交换的是内存块
				strcpy(myArray[i], myArray[j]);
				strcpy(myArray[j], tmpBuf);
			}
		}
	}
}
void main(){	
	int num = 4;
	char myBuf[30];
	// myArray：编译器只会关心：有10行，每行30列，这就解释了第二种内存模型
	// 多维数组myArray + 1，每加1会往后走30字节，即步长是30字节
	char myArray[10][30] = {"aaa", "bbb", "ccc", "ddd"};	
	
	// 打印 调用了上一种内存模型，会down掉
	// 问题的本质是两种内存模型中的myArray + 1不一样，即指针的步长不一样，指针所指向的内存空间的数据类不一样
	printMyArray_err(myArray, num);
	// 正确
	printMyArray(myArray, num);
	
	// 排序
	sortMyArray(myArray, num);
	
	// 用第一种内存模型求myArray的大小
	{
		// 对二级指针常量len1求大小，相当于求其指向的内存空间的大小――300字节 10行30列
		int len1 = sizeof(myArray);
		// myArray第一个元素是一级指针，相当于求其指向的内存空间（第一个元素）的大小，10行30列，每一行占30字节
		int len2 = sizeof(myArray[0]);
		// 求二维数组有多少行
		int size = len1/len2;
		printf("len1:%d, len2:%d, size:%d", len1, len2, size);
	}
}
二级指针做输入第三种模型
void main(){
	int i = 0;
	int j = 0;
	char** p2 = NULL;
	int num = 5;
	char* tmp;
	char tmpbuf[100];
	p2 = (char**)malloc(sizeof(char*) * num);
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	for(i = 0; i < num; i++){
		printf("%s", p2[i]);
	}
	
	// 排序 通过交换指针的方式来排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				tmp = p2[i];
				p2[i] = p2[j];
				p2[j] = tmp;
			}
		}
	}
	
	// 排序 通过交换指针指向的内存空间的数据来排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				// 老师写的
				strcpy(tmpbuf, p2[i]);
				strcpy(p2[i], p2[j]);
				strcpy(p2[j], tmpbuf);
				
				
				// 我写的
				// *tmpbuf = *p2[i];
				// *p2[i] = *p2[j];
				// *p2[j] = *tmpbuf;
			}
		}
	}
	
	// 释放内层的内存 后申请的先释放
	for(i = 0; i < num; i++){
		if(p2[i] != NULL){
			free(p2[i]);
			p2[i] = NULL;
		}
	}
	
	// 释放外层的内存 先申请的后释放
	if(p2 != NULL){
		free(p2);
	}
}

// 将上述程序改为指针做函数参数的
char** getMem(int num){
	int i = 0;
	char** p2 = NULL;
	p2 = (char**)malloc(sizeof(char*) * num);
	
	if(p2 == NULL){
		return NULL;
	}
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p2[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	return p2;
}
void printMyArray03(char** myArray, int num){
	int i = 0;

	for(i = 0; i < num; i++){
		// printf("%s", myArray[i]);
		printf("%s", *(myArray + i));
	}
}
void sortMyArray03(char** p2, int num){}{
	int i = 0;
	int j = 0;
	char* tmp;
	char tmpbuf[100];
	// 排序 通过交换指针的方式来排序
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				tmp = p2[i];
				p2[i] = p2[j];
				p2[j] = tmp;
			}
		}
	}
	
	// 排序 通过交换指针指向的内存空间的数据来排序
	for(i = 0; i < num; i++){
		for(j = i; j < num; j++){
			if(strcmp(p2[i], p2[j]) > 0){
				// 老师写的
				strcpy(tmpbuf, p2[i]);
				strcpy(p2[i], p2[j]);
				strcpy(p2[j], tmpbuf);
				
				
				// 我写的
				// *tmpbuf = *p2[i];
				// *p2[i] = *p2[j];
				// *p2[j] = *tmpbuf;
			}
		}
	}
}
void getMemFree03(char** p2, int num){
	int i = 0;
	// 释放内层的内存 后申请的先释放
	for(i = 0; i < num; i++){
		if(p2[i] != NULL){
			free(p2[i]);
			p2[i] = NULL;
		}
	}
	
	// 释放外层的内存 先申请的后释放
	if(p2 != NULL){
		free(p2);
	}
}
void main(){
	int i = 0;
	int j = 0;
	char** p2 = NULL;
	int num = 5;
	char* tmp;
	char tmpbuf[100];
	
	p2 = getMem(num);
	
	printMyArray03(p2, num);
	
	sortMyArray03(p2, num);
}

三种模型内存表示================================
void main(){
	int i = 0;
	
	// 第一种：指针数组
	char* p1[] = {"123", "456", "789"};
	
	// 第二种：二维数组
	char p2[3][4] = {"123", "456", "789"};
	
	// 第三种：手动分配二维内存
	char** p3 = (char**)malloc(3 * sizeof(char*));
	
	for(i = 0; i < 3; i++){
		p3[i] = (char*)malloc(10 * sizeof(char));
		sprintf(p3[i], "%d%d%d", i, i, i);
	}
}

多级指针======================================
int getMem52(char*** p3, int num){
	int i = 0;
	char** p2 = NULL;
	
	//注：是判断p3，而不是判断p3指向的内存空间的值，即不是判断*p3，*p3是可以为NULL的
	if(p3 == NULL){
		return -1;
	}
	
	p2 = (char**)malloc(sizeof(char*) * num);
	
	if(p2 == NULL){
		return NULL;
	}
	
	for(i = 0; i < num; i++){
		//相当于char buf[100];
		p2[i] = (char*)malloc(sizeof(char) * 100);
		sprintf(p2[i], "%d%d%d", i + 1, i + 1, i + 1);
	}
	
	*p3 = p2;
}
void getMemFree03(char*** p3, int num){
	char** tmp = NULL;
	if(p3 == NULL){
		return -1;
	}
	tmp = *p3;
	for(i = 0; i < num; i++){
		free(tmp[i]);
	}
	free(tmp);
	*p3 = NULL;
}
void main(){
	char** p2 = NULL;
	getMem52(&p2, 3);
	getMemFree(&p2, 3);
}

==============================
有一个字符串符合以下特征："aaa,bbb,ccc,ddd" 要求写一个函数，输出以下结果：
1、以逗号分割字符串，形成二维数组，并把结果输出
2、把二维数组行数运算结果也输出

void main(){
	int i = 0;
	char* str = "aaa,bbb,ccc,ddd,";
	char tmp = ',';
	char myArray[10][30];
	int row;
	int ret = 0;
	
	ret = split(str, tmp, myArray, &row);
	if(ret != 0){
		printf("func split err");
	}
	for(i = 0; i < row; i++){
		printf("%s \n", myArray[i]);
	}
}
// 参数c为分隔符
int split(const char* buf1, char c, char buf2[10][30], int* count){
	char* p = NULL;
	char* pTmp = NULL;
	int tmpCount = 0;
	
	p = buf1;
	pTmp = buf1;
	
	do{
		// 检索符合条件的位置 p后移
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				strncpy(buf2[tmpCount], pTmp, p - pTmp);
				buf2[tmpCount][p - pTmp] = '\0';
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	} while(*p!='\0');
	
	*count = tmpCount;
	return 0;
}

用第三种内存模型求解该问题==================================
// 改变二级指针的值，需要在函数中传入三级指针
int split(const char* buf1, char c, char*** myp3, int* count){
	char* p = NULL;
	char* pTmp = NULL;
	char** myp = NULL;
	int tmpCount = 0;
	int ret = 0;
	
	p = buf1;
	pTmp = buf1;
	
	//第一趟扫描，将第一维的长度存储在tmpCount中
	do{
		// 检索符合条件的位置 p后移
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	} while(*p!='\0');
	
	*count = tmpCount;
	
	myp = (char**)malloc(tmpCount * (char*));
	
	if(myp == NULL){
		ret = -1;
		printf("func split() err:%d (tmpCount * sizeof(char *))", ret);
		goto END;
		// return -1;
	}
	
	//先把申请来的内存清零，便于判断
	memset(myp, 0, tmpCount * sizeof(char*));
	
	tmpCount = 0;
	p = buf1;
	pTmp = buf1;
	
	do{
		p = strchr(p, c);
		if(p != NULL){
			if(p - pTmp > 0){
				// 加上1是为了给字符串最后的\0留下空间
				int len = p - pTmp + 1;
				myp[tmpCount] = (char*)malloc(len * sizeof(char));
				if(myp[tmpCount] == NULL){
					ret = -1;
					printf("func split() err:%d (malloc(len * sizeof(char))", ret);
					goto END;
					// return -1;
				}
				strncpy(myp[tmpCount], pTmp, p - pTmp);
				myp[tmpCount][p - pTmp] = '\0';
				tmpCount++;
				pTmp = p = p + 1;
			}
		}else{
			break;
		}
	}while(*p!='\0');
	
	
	// 这个函数是一个入口，多个出口（也就是有很多个地方（例如异常的时候）可以return出去），这样一来，有可能在申请下来的内存还没等到最后释放就出错了的时候，那这块申请的内存就永远释放不了了，从而导致了内存泄露，因此在所有的异常处理判断分支中都定位到END就可以统一处理异常，而且异常处理函数应该提出去
	END:
	if(ret != 0){
		FreeMem2(myp, count);
		myp = NULL;
		
		//还可以把myp的地址传进去
		//FreeMem3(&myp, count);
	}else{
		// 成功
		*myp3 = myp;
	}	
	return ret;
}
// 异常处理
void FreeMem2(char** myp, int count){
	int i = 0;
	if(myp == NULL){
		return ret;
	}
	for(i = 0; i < tmpCount; i++){
		if(myp[i] != NULL){
			free(myp[i]);
		}
	}
	if(myp != NULL){
		free(myp);
	}
}
void FreeMem3(char*** p, int count){
	int i = 0;
	char** myp = NULL;
	if(p == NULL){
		return;
	}
	myp = *p;
	if(myp == NULL){
		return;
	}
	for(i = 0; i < count; i++){
		if(myp[i] != NULL){
			free(myp[i]);
		}
	}
	if(myp != NULL){
		free(myp);
	}
	*p = NULL;
}
void main(){
	int ret = 0;
	int i = 0;
	char* p1 = "abcdef,accd";
	char cTem = ',';
	int nCount;
	
	ret = split(p1, cTem, &p, &nCount);
	
	if(ret != 0){
		printf("error");
	}
}


数组类型和多维数组本质
扫盲：
数组首元素地址和数组地址是两个不同的概念
数组名代表数组首元素的地址，它是个常量
	解释如下：变量本质是内存空间的别名，一定义数组就分配内存，内存也就固定了，所以数组在最开始起了名之后不可以修改
数组首元素的地址和数组的地址值相等


基础概念：
void main(){
	int a[] = {1, 2};
	int b[100] = {1, 3};
	int c[200] = {0}; //编译时就已经确定所有的值为0
	// c是数组首元素的地址 c+1 往后走4个字节
	// c语言规定：&c是整个数组的地址 &c+1 往后走200*4个字节
	
	memset(c, 0, sizeof(c)); //显式重置内存块
}

数据类型分为基础、非基础，思考角度应该发生变化
C语言中的数组有自己特定的类型
	数组的类型由元素类型和数组大小共同决定，比如：int array[5]的类型是int[5]

类型的本质是固定大小内存块的别名
void main(){
	typedef int (MyArrayType)[5]; //定义了一个数组数据类型
	
	int i = 0;
	MyArrayType myArray; // 相当于int myArray[5];
	
	for(i = 0; i < 5; i++){
		myArray[i] = i + 1;
	}
	
	// myArray代表数组首元素的地址
	printf("%d %d", myArray, myArray + 1); //1244992 1244996
	// &myArray代表整个数组的地址
	printf("%d %d", &myArray, &myArray + 1); //1244992 1245012
}

数组指针类型
定义数组指针类型方法1：
void main(){
	//回顾指针数组：
	char* myArray[] = {"aaa", "bbb"}; //这是指针数组
	
	// 数组指针时用一个指针来指向一个数组
	typedef int (MyArrayType)[5]; //定义了一个数组数据类型
	
	int i = 0;
	MyArrayType myArray; // 相当于int myArray[5]; 用类型定义变量
	MyArrayType* pArray; // 定义一个指针变量，这个指针变量指向一个数组
	
	int myArray2[5]; //myArray2相当于一级指针
	pArray = &myArray2; //相当于二级指针
	for(i = 0; i < 5; i++){
		(*pArray)[i] = i + 1; //相当于 myArray2[i] = i + 1;
	}
	for(i = 0; i < 5; i++){
		printf((*pArray)[i]);
	}
}


定义数组指针类型方法2：
void main(){
	//定义声明一个数组指针类型
	typedef int (*PArrayType)[5];
	PArrayType pArray; //告诉编译器给我分配一个指针变量
	int i;
	
	int c[5];
	
	pArray = &c;
	
	for(i = 0; i < 5; i++){
		(*pArray)[i] = i + 1;
	}
	
	for(i = 0; i < 5; i++){
		printf((*pArray)[i]);
	}
}


定义数组指针类型方法3：
//前两种方法都是通过类型来定义变量 比较麻烦
void main(){
	int (*pArray)[5]; //直接定义一个指向数组的数组指针变量
	int c[5];
	pArray = &c;
}

多维数组名本质剖析
void main(){
	int a[3][5];
	int i = 0;
	int j = 0;
	int tmp = 1;
	
	for(i = 0; i < 3; i++){
		for(j = 0; j < 5; j++){
			a[i][j] = tmp++;
		}
	}
	
	for(i = 0; i < 3; i++){
		for(j = 0; j < 5; j++){
			printf(a[i][j]);
		}
	}
	
	//多维数组名代表什么意思？
	//a + 1往后走了5 * 4 = 20个字节
	printf(a, a+1); // 1244964 1244984
	//&a + 1往后走了5 * 3 * 4 = 60个字节
	printf(&a, &a+1); // 1244964 1245024
	
	
	{
		//定义一个指向数组的指针变量
		int (*pArray)[5]; //告诉编译器给我分配4个字节的内存（32bit平台下）
		pArray = a;
		for(i = 0; i < 3; i++){
			for(j = 0; j < 5; j++){
				printf(pArray[i][j]); //多维数组名的本质是数组指针
			}
		}
	}
	
	// 对于二维数组a
	// (a + i) 第i行首地址
	// *(a + i) 是一级指针，代表第i行首元素的地址
	// *(a + i) + j 代表第i行第j列的元素的地址，相当于&a[i][j]
}

a[i][j] ==> a[0 + i][j] ==> *(a + i)[j] ==> *(a + i)[0 + j] ==> *(*(a + i) + j)

多维数组做函数参数退化原因
void printArray(int a[3][5]);
void printArray(int a[][5]);
void printArray(int (*a)[5]);

指针数组应用场景

main函数的参数
//char* argv[]其实就是二维数组，即二级指针，也就是char** argv，写成char* argv[]是为了更直观
//main函数由操作系统调用，main函数是操作系统和应用程序沟通的一个桥梁
//之所以写成main，是因为我们和操作系统商量好了，我用main定义入口，操作系统通过读取main进入应用程序
//env是操作系统传给我们的系统配置的所有环境变量的信息

//argv是我们自己往应用程序中传的参数，如果生成了一个a.exe的可执行文件，我们在命令行中执行该程序时，可以带一些参数：a.exe aaa bbb ccc ddd，main函数在调用的时候就会将aaa bbb ccc ddd这四个参数给argv
//argc是我们传入的参数的个数，例如a.exe aaa bbb ccc ddd执行的时候argc就是4
int main(int argc, char* argv[], char**env){}

//指针数组自我结束能力：最后一项给一个0
char* c_keyword1[] = {
	"while",
	"do",
	"for",
	"static",
	'\0'
};
char* c_keyword2[] = {
	"while",
	"do",
	"for",
	"static",
	0
};
char* c_keyword3[] = {
	"while",
	"do",
	"for",
	"static",
	NULL
};

结构体==================================
struct Teacher{
	char name[64];
	int age;
	int id;
}
void main(){
	struct Teacher t1;
}

//类型重定义
typedef struct Teacher{
	char name[64];
	int age;
	int id;
}Teacher
void main(){
	Teacher t1; //用typedef重定义之后struct才可以省略
}

struct Student{
	char name[64];
	int age;
}s1, s2; //定义类型的同时定义变量

struct {
	char name[64];
	int age;
}s3, s4; //匿名类型定义变量

初始化结构体类型的变量=======================
void main(){
	Teacher t1 = {"aaa", 12, 12};
}

定义结构体时初始化
struct Student{
	char name[64];
	int age;
}s1 = {"name", 21};

struct {
	char name[64];
	int age;
}s1 = {"name", 21};

成员引用======================
void main(){
	Teacher t1;
	//点操作符是寻址操作，是age相对于t1的偏移量，在CPU中进行，并没有操作内存
	t1.age = 31;
	strcpy(t1.name, "aaa");
	
	//通过指针操作内存空间
	Teacher* p = NULL;
	p = &t1;
	// ->运算操作也是寻址操作，相对于t1的偏移量，在CPU中进行，并没有操作内存
	printf(p->age);
}

结构体做函数参数=========================
结构体等号操作
void main(){
	Teacher t1 = {"aaaa", 32, 11};
	Teacher t2;
	Teacher t3;
	memset(&t3, 0, sizeof(t3));
	
	t2 = t1;
	
	//编译器给我们提供简单的=赋值操作，我们要顺从
	printf("%s", t2.name); //"aaa"
	printf("%d", t2.age); //32
	
	copyTeacher(t3, t1);
	
	printf("%s", t2.name); //乱码
	printf("%d", t2.age); //乱码
	//拷贝不成功的原因是to的内存空间在copyTeacher函数执行完之后释放，并没有改变t3的值
	
	copyTeacher02(&t3, &t1);
	
	printf("%s", t2.name); //"aaa"
	printf("%d", t2.age); //32
}

void copyTeacher(Teacher to, Teacher from){
	to = from;
}
void copyTeacher02(Teacher* to, Teacher* from){
	*to = *from;
}


结构体数组===================================
typedef struct Teacher{
	char name[64];
	int age;
	int id;
}Teacher;
void printTeacher(Teacher* array, int num){
	int i = 0;
	
	for(i = 0; i < num; i++){
		printf("age", array[i].age);
	}
}
Teacher* createTeacher(int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return NULL;
	}
}
void sortTeacher(Teacher* array, int num){
	int i;
	int j;
	Teacher tmp;
	
	for(i = 0; i < num; i++){
		for(j = i + 1; j < num; j++){
			if(array[i].age > array[j].age){
				tmp = array[i];
				array[i] = array[j];
				array[j] = tmp;
			}
		}
	}
}
void main(){
	Teacher Array[3];
	int i;
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(Array[i].age));
	}
	
	for(i = 0; i < 3; i++){
		printf("%d", Array[i].age);
	}
	
	printTeacher(Array, 3);
	
	sortTeacher(Array, 3);
}
=====================================
Teacher* createTeacher(int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return NULL;
	}
	return tmp;
}
void freeTeacher(Teacher* p){
	if(p != NULL){
		free(p);
	}
}
void main(){
	Teacher* pArray = NULL;
	pArray = createTeacher(3);
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
	}
	
	sortTeacher(pArray, 3);
	
	printTeacher(pArray, 3);
}
====================================
int createTeacher(Teaher** pT, int num){
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p){
	if(p != NULL){
		free(p);
	}
}
void main(){
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
	}
	
	sortTeacher(pArray, 3);
	
	printTeacher(pArray, 3);
}
结构体套一级指针=====================
typedef struct Teacher{
	char name[64];
	char* aliasname;
	int age;
	int id;
}Teacher;
int createTeacher(Teaher** pT, int num){
	int i = 0;
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	memset(tmp, 0, sizeof(Teacher) * num);
	
	for(i = 0; i < num; i++){
		tmp[i].aliasname = (char*)malloc(60);
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p, int num){
	if(p == NULL){
		return;
	}
	for(i = 0; i < num; i++){
		if(p[i].aliasname != NULL){
			free(p[i].aliasname);
		}
	}
	free(p);
}
void main(){
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
		scanf("%d", pArray[i].name); // 向指针所指向的内存空间拷贝数据，char name[64]这种写法就使得结构体在初始化时(Teacher* pArray = NULL;)就已经分配了对应的内存
		scanf("%d", pArray[i].aliasname); // 向指针所指向的内存空间拷贝数据，但前提是这个指针所指向的内存空间得有才可以，char* aliasname只是一个指针，分配了4个字节的空间，并没有分配这个指针指向的内存空间
	}
	
	freeTeacher(pArray, 3);
}
结构体套二级指针=====================
typedef struct Teacher{
	char name[64];
	char* aliasname;
	char** stuame;
	int age;
	int id;
}Teacher;
int createTeacher(Teaher** pT, int num){
	int i = 0;
	int j = 0;
	Teacher* tmp = NULL;
	tmp = (Teacher*)malloc(sizeof(Teacher) * num);
	if(tmp == NULL){
		return -1;
	}
	memset(tmp, 0, sizeof(Teacher) * num);
	
	for(i = 0; i < num; i++){
		char** p;
		tmp[i].aliasname = (char*)malloc(60);
		p = (char**)malloc(3 * sizeof(char*));
		for(j = 0; j < 3; j++){
			p[j] = (char*)malloc(120);
		}
		tmp[i].stuname = p;
	}
	*pT = tmp;
	return 0;
}
void freeTeacher(Teacher* p, int num){
	int i = 0;
	int j = 0;
	if(p == NULL){
		return;
	}
	for(i = 0; i < num; i++){
		if(p[i].aliasname != NULL){
			free(p[i].aliasname);
		}
		
		if(p[i].stuname != NULL){
			char** myp = p[i].stuname;
			for(j = 0; j < 3; j++){
				if(myp[j] != NULL){
					free(myp[j]);
				}
			}
			free(myp);
			p[i].stuname = NULL;
		}
	}
	free(p);
}
void main(){
	int i;
	int j;
	int ret = 0;
	Teacher* pArray = NULL;
	ret = createTeacher(&pArray, 3);
	
	for(i = 0; i < 3; i++){
		scanf("%d", &(pArray[i].age));
		scanf("%d", pArray[i].name);
		scanf("%d", pArray[i].aliasname);
		for(j = 0; j < 3; j++){
			scanf("%s", pArray[i].stuname[j]);
		}
	}
	
	freeTeacher(pArray, 3);
}

综合案例========================================
// 把第一种内存模型第二种内存模型结果copy到第三种内存模型中，并排序，打印
int sort(char** myp1, int num1, char (*myp2)[30], int num2, char*** myp3, int* num3){
	char** p3 = NULL;
	int i = 0;
	int j = 0;
	int k = 0;
	int tmplen = 0;
	char* tmpP = NULL;
	
	p3 = (char**)malloc((num1 + num2) * sizeof(char*));
	if(p3 == NULL){
		return -1;
	}
	
	for(i = 0; i < num1; i++){
		tmplen = strlen(myp1[i]) + 1;
		p3[i] = (char*)malloc(tmplen * sizeof(char));
		if(p3[i] == NULL){
			return -2;
		}
		strcpy(p3[i], myp1[i]);
	}
	
	for(j = 0; j < num2; j++, i++){
		tmplen = strlen(myp2[j]) + 1;
		p3[i] = (char*)malloc(tmplen * sizeof(char));
		if(p3[i] == NULL){
			return -3;
		}
		strcpy(p3[i], myp2[j]);
	}
	
	tmplen = *num3 = num1 + num2;
	//排序
	for(i = 0; i < tmplen; i++){
		for(j = i; j < tmplen; j++){
			if(strcmp(p3[i], p3[j]) > 0){
				tmpP = p3[i];
				p3[i] = p3[j];
				p3[j] = tmpP;
			}
		}
	}
	
	*myp3 = p3;
	
	return ret;
}
int sortFree(char*** myp, int len){
	int i = 0;
	char** p = NULL;
	
	if(myp == NULL){
		return;
	}
	
	p = *myp;
	if(p == NULL){
		return;
	}
	
	for(i = 0; i < len; i++){
		free(p[i]);
	}
	free(p);
	// 只有传入三级指针才可以将二级指针所指向的内存空间清空，从而防止野指针的出现
	*myp = NULL;
}
int main(){
	char* p1[] = {"aaa","aaa","aaa","aaa"};
	char buf2[10][30] = {"111","111","111","111"};
	char** p3 = NULL;
	int len1;	
	int len2;	
	int len3;
	int ret = 0;

	len1 = sizeof(p1)/sizeof(*p1);
	len2 = 3;
	
	ret = sort(p1, len1, buf2, len2, &p3, &len3);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	for(i = 0; i < len3; i++){
		printf("%s", p3[i]);
	}
}

结构体的深拷贝和浅拷贝=================================
typedef struct Teacher{
	char name[64];
	int age;
	char* pname2;
}Teacher;
void copyTeacher(Teacher* to, Teacher* from){
	//*to = *from;相当于memcpy(to, from, sizeof(Teacher));但是这两种操作都是浅拷贝，不会把指针变量指向的内存空间拷贝过去
	memcpy(to, from, sizeof(Teacher));
}
//深拷贝
void deepCopyTeacher(Teacher* to, Teacher* from){
	*to = *from;
	to->pname2 = (char*)malloc(100);
	strcpy(to->pname2, from->pname2);
}
void main(){
	Teacher t1;
	Teacher t2;
	
	strcpy(t1.name, "name1");
	t1.pname2 = (char*)malloc(100);
	strcpy(t1.pname2, "ssss");
	
	//t1赋给t2
	copyTeacher(&t2, &t1);
	
	if(t1.pname2 != NULL){
		free(t1.pname2);
		t1.pname2 = NULL;
	}
	// 如果是浅拷贝的话，t1和t2这两个变量中存储的地址是一样的，而此时该地址指向的内存空间已经在上面的free(t1.pname2)中释放了，再去free(t2.pname2);就会出问题
	if(t2.pname2 != NULL){
		free(t2.pname2);
		t2.pname2 = NULL;
	}
}

偏移量====================
//一旦结构体定义下来，则结构体中的成员，内存布局就定下来了
//age地址减去64就是结构体的内存地址
typedef struct AdvTeacher{
	char name[64];
	int age;
	int p;
	char* pname2;
}AdvTeacher;
void main(){
	AdvTeacher t1;
	AdvTeacher* p = NULL;
	//还没给p分配内存，直接往p里面拷贝，会down掉
	//strcpy(p1, "dddd");
	p - 1; //p - 1这个操作是在CPU中运算的，并没有操作任何内存 *(p - 1)这个操作才会去取p - 1处指向的内存
	{
		int offsize = (int)&(p->age); //offsize为64，64这个值就是偏移量，偏移了name成员的长度――64字节
	}
	{
		int offsize = (int)&(((AdvTeacher*)0)->age); //64
	}
}


文件操作===============================
按字符读写文件
fputc================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	//两种都可以，但是第一种在Linux下不兼容，因此我们通常用第二种
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	for(i = 0; i < strlen(a); i++){
		fputc(a[i], fp);
	}
	fclose(fp);
}

fgetc========================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	
	while(!feof(fp)){
		char tmpc = fgetc(fp);
		printf("%c", tmpc);
	}
	
	if(fp != NULL){
		fclose(fp);
	}	
}

按照行读取文件==================
fputs==================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char a[27] = "abcdefg";
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	fputs(a, fp);
	fclose(fp);
}

fgets========================
void main(){
	FILE* fp = NULL;
	char* filename = "c:\\1.txt";
	char* filename2 = "c:/1.txt";
	char buf[1024];
	
	fp = fopen(filename2, "r+");
	if(fp == NULL){
		printf("open fail");
		return;
	}
	printf("open succ");
	
	while(!feof(fp)){
		// 会把\n也拷贝到buf中
		// 内存打包技术：内存首地址+内存长度
		char* p = fgets(buf, 1024, fp); //C函数库会一行一行的拷贝数据到buf指针所指的内存空间中，并且变成C风格的字符串
		if(p == NULL){
			goto End;
		}
		printf("%s", buf);
	}
End:	
	if(fp != NULL){
		fclose(fp);
	}	
}

按照块的方式操作文件==================
//直接把内存数据写入到文件中
typedef struct Teacher{
	char name[64];
	int age;
}Teacher;
void main(){
	//fwrite======================
	int i = 0;
	FILE* fp = NULL;
	char* fileName = "c:/1.txt";
	Teacher tArray[3];
	int myN = 0;
	
	for(i = 0; i < 3; i++){
		sprintf(tArray[i].name, "%d%d%d", i + 1, i + 1, i + 1);
		tArray[i].age = i + 31;
	}
	
	fp = fopen(fileName, "rb");
	if(fp == NULL){
		printf("error");
	}
	
	for(i = 0; i < 3; i++){
		// 第一个参数是从哪个内存块开始
		// 第二个参数是写多长
		// 第三个参数是写了多少次
		// 第四个参数是将要写入的文件指针
		// 返回值有没有写满磁盘
		myN = fwrite(&tArray[i], sizeof(Teacher), 1, fp);
	}
	
	if(fp != NULL){
		fclose(fp);
	}
	
	
	//fread=======================
	int i = 0;
	FILE* fp = NULL;
	char* fileName = "c:/1.txt";
	Teacher tArray[3];
	int myN = 0;
	
	for(i = 0; i < 3; i++){
		sprintf(tArray[i].name, "%d%d%d", i + 1, i + 1, i + 1);
		tArray[i].age = i + 31;
	}
	
	fp = fopen(fileName, "wb");
	if(fp == NULL){
		printf("error");
	}
	
	for(i = 0; i < 3; i++){
		myN = fread(&tArray[i], sizeof(Teacher), 1, fp);
		//myN = fwrite(&tArray[i], sizeof(Teacher), 1, fp);
	}
	
	for(i = 0; i < 3; i++){
		printf("%s %s", tArray[i].name, tArray[i].age);
	}
	
	if(fp != NULL){
		fclose(fp);
	}	
}

实例：配置文件读写=================================
程序启动时提示
输入1：写配置文件
输入2：读配置文件
输入0：退出

模块划分:
界面（集成测试环境）
接口：读配置文件 写配置文件



项目结构==================================================
cfg_op.h文件==========
#ifndef __CFG_OP_H__
#define __CFG_OP_H__

#ifdef __cplusplus
extern "C" {

//读配置文件
int GetCfgItem(char* pFileName, char* pKey, char* pValue, int* pValueLen);
//写配置文件
int WriteCfgItem(char* pFileName, char* pItemName, char* pItemValue, int itemValueLen);

#ifdef __cplusplus
}
#endif

#endif

cfg_op.c文件===========
#define MaxLine 2048
int GetCfgItem(char* pFileName, char* pKey, char* pValue, int* pValueLen){
	FILE* fp = NULL;
	int ret = 0;
	char* pTmp = NULL;
	char* pBegin = NULL;
	char* pEnd = NULL;
	char lineBuf[MaxLine]; //假设一行数据不会超过2048
	fp = fopen(pFileName, "r");
	if(fp == NULL){
		ret = -1;
		return ret;
	}
	while(!feof(fp)){
		memset(lineBuf, 0, sizeof(lineBuf));
		//一行一行读
		fgets(lineBuf, MaxLine, fp);
		//测试一下：
		//printf("%s", lineBuf);
		
		pTmp = strschr(lineBuf, '=');
		if(pTmp == NULL){
			continue;
		}
		
		//当前循环到的行是否有key
		pTmp = strstr(lineBuf, pKey);
		if(pTmp == NULL){
			continue;
		}
		
		pTmp = pTmp + strlen(pKey);
		//将pTmp指向=前的一个字符
		pTmp = strchr(pTmp, '=');
		if(pTmp == NULL){
			continue;
		}
		//将pTmp指到=的后面
		pTmp = pTmp + 1;
		//测试一下 printf("%s", pTmp);
		
		//拿到value的起点
		while(1){
			if(*pTmp == ' '){
				pTmp++;
			}else{
				pBegin = pTmp;
				if(*pBegin == '\n'){
					//如果是回车，证明这个key没有对应的值
					printf("%s没有对应的值", pKey);
				}
				break;
			}
		}
		
		//拿到value的终点
		while(1){
			if(*pTmp == ' ' || *pTmp == '\n'){
				break;
			}else{
				pTmp = pTmp + 1;
			}
		}
		pEnd = pTmp;
		
		*pValueLen = pEnd - pBegin;
		memcpy(pValue, pBegin, pEnd - pBegin);
		break;
	}
End:
	if(fp != NULL){
		fclose(fp);
	}
	return 0;
}

int WriteCfgItem(char* pFileName, char* pKey, char* pValue, int itemValueLen){
	int rv = 0;
	int iTag = 0;
	int length = 0;
	FILE* fp = NULL;
	char lineBuf[MaxLine];
	char* pTmp = NULL;
	char* pBegin = NULL;
	char* pEnd = NULL;
	char fileBuf[1024 * 8] = {0};
	
	if(pFileName == NULL || pKey == NULL || pValue == NULL){
		rv = -1;
		printf("error");
		goto End;
	}
	
	// 以读写的方式打开文件
	fp = fopen(pFileName, "r+");
	// 如果打开失败了，仅提示一下，后面继续以w+t（如果文件没有就新建一个）的方式再次打开
	if(fp == NULL){
		rv = -2;
		printf("error");
	}
	
	// 如果文件不存在就新建
	if(fp == NULL){
		fp = fopen(pFileName, "w+t");
		if(fp == NULL){
			rv = -3;
			printf("error");
			goto End;
		}
	}
	
	//把文件指针从0位置开始，移动到文件末尾，便于后面通过ftell获取长度
	fseek(fp, 0L, SEEK_END);
	
	//获取文件长度
	length = ftell(fp);
	
	//再将指针指向文件头部
	fseek(fp, 0L, SEEK_SET);
	
	if(length > 1024 * 8){
		rv = -3;
		printf("文件长度太长");
		goto End;
	}
	
	while(!feof(fp)){
		//读每一行
		memset(lineBuf, 0, sizeof(lineBuf));
		pTmp = fgets(lineBuf, MaxLine, fp);
		if(pTmp == NULL){
			break;
		}
		
		//如果当前行有传进来的key，将文件指针移到key处
		pTmp = strstr(lineBuf, pKey);
		if(pTmp == NULL){
			//如果当前行没有传进来的key，copy到filebuf中
			strcat(fileBuf, lineBuf);
		}else{
			//传进来的key在当前行，则替换旧的行，再copy到fileBuf中
			sprintf(lineBuf, "%s=%s\n", pKey, pValue);
			strcat(fileBuf, lineBuf);
			iTag = 1;
		}
	}
	
	if(iTag == 0){
		//如果key不在任何一行中，追加
		fprintf(fp, "%s = %s\n", pKey, pValue);
	}else{
		//如果有key，重新创建文件
		if(fp != NULL){
			fclose(fp);
			fp = NULL; //避免野指针
		}
		fp = fopen(pFileName,"w+t");
		if(fp == NULL){
			rv = -4;
			printf("error");
			goto End;
		}
		fputs(fileBuf, fp);
	}
	
End:
	if(fp != NULL){
		fclose(fp);
	}
	
	return rv;
}

入口文件==================
#include "cfg_op.h"

#define CFGNAME "c:/mycfg.ini";
int TGetCfg(){
	char name[1024] = {0};
	char value[1024] = {0};
	int ret = 0;
	int len = 0;
	
	//从键盘中获取key
	scanf("%s", name);

	ret = GetCfgItem(CFGNAME, name, value, &len);
	if(ret != 0){
		printf("err");
		return ret;
	}
	return 0;
}

int TWriteCfg(){
	char name[1024] = {0};
	char value[1024] = {0};
	int ret = 0;
	
	//从键盘中获取key
	scanf("%s", name);
	scanf("%s", value);

	ret = WriteCfgItem(CFGNAME, name, value, strlen(value));
	if(ret != 0){
		printf("err");
		return ret;
	}
	return 0;
}
void main(){
	int choice;
	for(;;){
		printf("菜单内容。。。略");
		scanf("%d", &choice);
		switch(choice){
			case 1:
				TWriteCfg();
				break;
			case 2:
				TGetCfg();
				break;
			case 0:
				exit(0); //return也可以
				break;
			default:
				exit(0);
		}
	}
}


大文件加密======================================
文件比较大时不可能把整个文件都加载到内存中整体加密
des.h========
#ifndef _OPENDESS_H_
#define _OPENDESS_H_

#ifdef __cplusplus
extern "C" {
#endif

int DescEnc(
	unsigned char* pInData,
	int nInDataLen,
	unsigned char* pOutData,
	int* pOutDataLen
);

int DesDec(
	unsigned char* pInData,
	int nInDataLen,
	unsigned char* pOutData,
	int* pOutDataLen
);

#ifdef __cplusplus
}
#endif

#endif


加密解密测试============
#include "des.h" //引入加密解密库
void main(){
	int ret = 0;
	char* plain = "123456";
	int plainlen = strlen(plain);
	
	char plain2[4096];
	int plainlen2 = strlen(plain2);
	
	unsigned char cryptbuf[4096];
	int cryptlen = 0;
	
	ret = DescEnc(
		plain,
		plainlen,
		cryptbuf,
		&cryptlen
	);
	if(ret != 0){
		printf("error");
	}

	ret = DesDec(
		cryptbuf,
		cryptlen,
		plain2,
		&plainlen2
	);
	if(ret != 0){
		printf("error");
	}
}

入口文件====================
#include "des.h"

int FileSymEnc(const char* pfile1, const char* pfile2){
	FILE* fp1 = NULL;
	FILE* fp2 = NULL;
	unsigned char plainbuf[4096];
	int plainlen = 0;
	int plainlen2 = 0;
	int ret = 0;
	unsigned char cryptbuf[4096];
	int cryptlen = 0;
	
	fp1 = fopen(pfile1, "rb");
	if(fp1 == NULL){
		goto End;
	}
	
	fp1 = fopen(pfile1, "wb");
	if(fp1 == NULL){
		goto End;
	}
	
	while(!feof(fp1)){
		//返回取到的长度
		plainlen = fread(plainbuf, 1, 4096, fp1);
		
		ret = DescEnc(
			plainbuf,
			plainlen,
			cryptbuf,
			&cryptlen
		);
		if(ret != 0){
			printf("error");
			return ret;
		}
		
		//将读到的数据写入fp2所指向的文件中
		plainlen2 = fwrite(cryptbuf, 1, cryptlen, fp2);
		//这里假设明文段和加密段的长度一样
		if(plainlen2 != plainlen){
			ret = -3;
			printf("error: 磁盘已满");
			goto End;
		}
	}
End:
	if(fp1 != NULL){
		fclose(fp1);
	}
	if(fp2 != NULL){
		fclose(fp2);
	}
	
	return 0;
}
void main(){
	const char* file1 = "c:/22.txt";
	const char* file2 = "c:/22enc.txt";
	int ret = 0;
	
	ret = FileSymEnc(file1, file2);
	
	if(ret != 0){
		printf("error");
	}
}

=========================================
socketclient.lib //资源描述文件 描述socketclient.dll
socketclient.dll //动态库 （函数二进制码集合、里面有函数的函数体） 动态库是有规范的 各个操作系统下这个规范是不一样的

动态库测试环境搭建======================
#include "socketclientdll.h"
int main(){
	int ret = 0;
	void* handle = NULL;
	
	unsigned char buf[128];
	int buflen = 3;
	
	unsigned char outbuf[128];
	int outbuflen = 3;
	
	strcpy(buf, "12345");
	
	//客户端初始化，获取handle上下文，cltSocketInit就是调用的动态库里面的方法
	ret = cltSocketInit(&handle);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//客户端发报文
	ret = cltSocketSend(handle, buf, buflen);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//客户端收报文
	ret = cltSocketRev(handle, outbuf, &outbuflen);
	if(ret != 0){
		printf("error");
		return ret;
	}
	
	//释放客户端资源
	cltSocketDestroy(handle);
}

socketclient动态库====================
typedef struct _SCK_HANDLE{
	char version[64];
	char ip[128];
	int port;
	char *p;
	int plen;
}_SCK_HANDLE; //动态库内部的数据类型，不像让测试程序（上层应用）知道

//通过增加_declspec(dllexport)注解，表明下面的这个方法是该动态库对外开放出去的方法
_declspec(dllexport)
int cltSocketInit(void** handle){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	printf("func cltSocketInit() begin");
	hdl = (_SCK_HANDLE*)malloc(sizeof(_SCK_HANDLE));
	if(hdl == NULL){
		ret = -1;
		printf("error");
		return ret;
	}
	memset(hdl, 0, sizeof(_SCK_HANDLE));
	strcpy(hdl->ip, "192.168.1.2");
	hdl->port = 8081;
	*handle = hdl;
	
	printf("func cltSocketInit() end");
	return 0;
}

_declspec(dllexport)
// 客户端发报文
int cltSocketSend(void* handle, unsigned char* buf, int buflen){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	hdl->p = (unsigned char*)malloc(buflen* sizeof(unsigned char));
	if(hdl->p){
		ret = -1;
		printf("error");
		return ret;
	}
	memcpy(hdl->p, buf, buflen);
	hdl->plen = buflen;

	return 0;
}

_declspec(dllexport)
int cltSocketRev(void* handle, unsigned char* buf, int buflen){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	memcpy(buf, hdl->p, hdl->plen);
	*buflen = hdl->plen;
	
	return 0;
}

_declspec(dllexport)
int cltSocketDestroy(void* handle){
	_SCK_HANDLE *hdl = NULL;
	int ret = 0;
	
	hdl = (_SCK_HANDLE*)handle;
	
	if(hdl->p){
		free(hdl->p);
	}
	free(hdl);
}

==================================
检查内存泄露的工具memwatch.h memwatch.c

win32环境下动态链接库（DLL）编程原理--非重点，有兴趣可以研究下
需要在visual studio中 动态库测试搭建中的链接器里面加入导入的动态库的lib文件，这样程序在链接的时候就可以使用这里面的方法了

visual studio中创建动态库的话需要在开始创建项目时选择dll动态库选项，动态库会生成一个dll和lib文件

===================================
typedef struct Student{
	char name[64];
	int id;
}
typedef struct Teacher{
	char name[64];
	int id;
	char* p;
	char** p2;
	Student s1; //结构体套结构体
	Student* p3; //结构体套指针
	//Teacher t1; //结构体套自身类型的结构体元素，非法，因为结构体的本质就是定义一种数据类型，定义数据类型就需要分配内存空间，而编译器还没给结构体分配完内存空间时又遇到了一个自身类型的结构体，这个成员的大小肯定无法确定，因此非法，但是结构体中可以有自身类型的指针成员
	struct Teacher* pt1; //结构体中可以有自身类型的指针成员
}Teacher;
void main(){
	
}

链表=========================================
typedef struct Teacher{
	int data;
	struct Teacher* next;
}Teacher;
void main(){
	//静态链表：固定节点数，如果放在独立的方法中创建节点的话方法执行完毕节点内存也就释放了
	//动态链表：
	Teacher t1;
	Teacher t2;
	Teacher t3;
	
	t1.data = 1;
	t2.data = 2;
	t3.data = 3;
	
	t1.next = &t2;
	t2.next = &t3;
	t3.next = NULL;
}

============================================
typedef struct Node{
	int data;
	struct Node* next;
}SList;

// 创建链表
SList* SList_Create();

// 遍历链表
int SList_Print(SList* pHead);

// 插入节点
int SList_NodeInsert(SList* pHead, int x, int y);

// 删除节点
int SList_NodeDel(SList* pHead, int y);

// 链表销毁
int SList_Destroy(SList* pHead);

// 创建链表
SList* SList_Create(){
	SList* pHead = NULL;
	SList* pM = NULL;
	SList* pCur = NULL;	
	int data;

	pHead = (SList*)malloc(sizeof(SList));
	if(pHead == NULL){
		return -1;
	}
	pHead->data = 0;
	pHead->next = NULL;
	
	scanf("%d", &data);
	
	pCur = pHead;
	
	while(data != -1){
		pM = (SList*)malloc(sizeof(SList));
		if(pM == NULL){
			return -1;
		}
		pM->data = data;
		pM->next = NULL;
		
		pCur->next = pM;
		pCur = pM;
		
		scanf("%d", &data);
	}
	
	return pHead;
}

// 遍历链表
int SList_Print(SList* pHead){
	SList* pTmp;
	if(pHead == NULL){
		return -1;
	}
	
	pTmp = pHead->next;
	while(pTmp != NULL){
		printf("%d", pTmp->data);
		pTmp = pTmp->next;
	}
	return NULL;
}

// 插入节点
int SList_NodeInsert(SList* pHead, int x, int y){
	SList* pPre = NULL;
	SList* pNext = NULL;
	SList* pCur = NULL;
	SList* pM = NULL; // 即将插入的新节点

	pM = (SList*)malloc(sizeof(SList));
	if(pM == NULL){
		return -1;
	}
	
	pM->next = NULL;
	pM->data = y;
	
	pPre = pHead;
	pCur = pHead->next;
	while(pCur){
		if(pCur->data == x){
			break;
		}
		pPre = pCur;
		pCur = pCur->next;
	}
	
	// 让新节点连接后续链表
	pM->next = pPre->next;
	// 让前驱节点连接新节点
	pPre->next = pM;
	
	return 0;
}

// 删除节点
int SList_NodeDel(SList* pHead, int y){
	SList* pM;
	SList* pCur;
	SList* pPre;
	int data;
	
	pPre = pHead;
	pCur = pHead->next;
	
	while(pCur){
		if(pCur->data == y){
			break;
		}
		pPre = pCur;
		pCur = pCur->next;
	}
	
	if(pCur == NULL){
		printf("没有找到要删除的节点");
		return -1;
	}else{
		pNext->next = pCur->next;
		if(pCur != NULL){
			free(pCur);
		}
	}
	
	return 0;
}

// 链表销毁
int SList_Destroy(SList* pHead){
	SList* tmp = NULL;
	if(pHead == NULL){
		return -1;
	}
	
	tmp = pHead;
	while(pHead != NULL){
		// 注意不可以缓存pHead
		tmp = pHead->next;
		free(pHead);
		pHead = tmp;
	}
	return NULL;
}

// 链表逆置
int SList_Reverse(SList* pHead){
	SList* p; // 前驱指针
	SList* q; // 当前指针
	SList* t; // 当前指针下一个节点
	
	// 排除头结点为空 只有头节点 只有头结点和第二个节点的情况
	if(pHead == NULL || pHead->next == NULL || pHead->next->next == NULL){
		return 0;
	}
	
	// 初始化
	p = pHead->next;
	q = pHead->next->next;
	
	// 从左到右逆置节点
	while(q){
		t = q->next;
		q->next = p;
		p = q;
		q = t;
	}
	
	// 头结点变成尾节点
	pHead->next->next = NULL;
	pHead->next = p;
	
	return 0;
}

void main(){
	int ret = 0;
	SList* pHead = NULL;
	
	// 创建链表
	pHead = SList_Create();
	ret = SList_Print(pHead);
	
	// 向链表中插入节点
	ret = SList_NodeInsert(pHead, 20, 19);
	ret = SList_Print(pHead);
	
	// 删除节点
	ret = SList_NodeDel(pHead, 19);
	ret = SList_Print(pHead);
}

C++============================================================================================================
#include "iostream" // 包含C++的头文件

using namespace std; // 使用命名空间 std 标准的命名空间（在这个命名空间中定义了很多标准定义）

void main(){
	// cout是一个对象 标准输出 相当于黑窗口
	// 左移操作符<<在C++中不仅仅承担了左移的功能，在此作用相当于把"hello..."输出到cout中，这就是C++操作符的重载
	// endl是回车换行
	// 这条语句整体意思是将"hello..."打印到屏幕并且回车换行
	cout << "hello..." << endl;
}

分别用面向过程和面向对象 用C++求圆周长与面积
#include "iostream"
using namespace std;

// 求圆面积
void main(){
	double r = 0;
	double s = 0;
	
	cout << "请输入圆半径:";
	// cin相当于键盘 标准输入
	// 从键盘中输入的数据流入到r变量中
	cin >> r;
	
	s = 3.14 * r * r;
	cout << "圆面积是" << s << endl;
}


面向对象===============
// 定义一个自定义数据类型
struct Circle{
	double m_s; //圆面积
	double m_r; //圆半径
}
// 类似于上面结构体的定义
class MyCircle{
	public:
		double m_s; //圆面积
		double m_r; //圆半径
	public:
		// 成员函数
		void setR(double r){
			m_r = r;
		}
		double getR(){
			return m_r;
		}
		double getS(){
			m_s = 3.14 * m_r * m_r;
			return m_s;
		}
	// protected:
	// private:
}
void main(){
	MyCircle c1, c2, c3; // 用类定义变量
	double r;
	cout << "请输入C1圆的半径:";
	cin >> r;
	// 给c1圆的属性赋值
	c1.setR(r);
	cout << "c1面积" << c1.getS() <<endl;
}

C++对C的加强：
namespace命名空间加强
iostream中没有引入标准的std 需要我们手工加上using namespace std;否则输出内容需要写成
std::cout << "xxx" << std::endl;

C++标准为了和C区分开，也为了正确使用命名空间，规定头文件不使用后缀.h

实用性增强：变量不必在最开头定义
register关键字加强，C语言中无法取得register变量地址，但C++可以，C++编译器有自己的优化方式，即使不用register关键字也会做优化

变量检测增强：
int a = 1;
int a;
上面的定义C语言是允许的，但是C++不可以

struct类型加强
C语言中定义一个struct结构体，如果在定义时没加typedef，使用该结构体定义变量时必须加上struct关键字，但是C++里面不需要加上struct关键字，struct class这两个关键字完成的功能是一样的，但是二者也有一定区别，在C++的结构体中也可以加上public private等：
struct Teacher{
	public:
}
这样做的功能我们以后再讲

C++中所有变量和函数必须有类型：c语言中不定义函数的参数或返回值类型也是可以的，c++中不可以

新增bool类型关键字，占1个字节bool b1 = 10; C++编译器会将其转为1

三目运算符功能增强
int a = 10;
int b = 20;
(a < b ? a : b) = 30; //在C语言中这行语句编译报错，报表达式不能做左值，也就是说C语言中表达式的返回结果是一个数值，在在C++中表达式返回的是一个变量的本身，因此就可以给它赋值了
要想当做左值，就要让表达式返回一个内存空间，即内存首地址，即指针，可以猜测编译器内部的做法是
*(a < b ? &a : &b) = 30; //这种写法在C语言编译器中也是可以通过的

const=======================================================
const int a;和int const a;是一样的

const int *c; //const修饰指向的内存空间，代表c指向的内存空间不可以修改
int* const d; //const修饰指针，代表d是一个常量指针
const int * const e; //不论是指针本身，还是指针指向的内存空间都不可以修改

int operatorTeacher(const Teacher* pT){
	pT->age = 10; //报错 pT指向的内存空间不可以改
}

int operatorTeacher(Teacher* const pT){
	pT->age = 10; //不报错 pT指向的内存空间可以改
	pT = NULL; //报错 pT本身不可以改
}

int operatorTeacher(const Teacher* const pT){
	pT->age = 10; //报错 pT指向的内存空间不可以改
	pT = NULL; //报错 pT本身不可以改
}

C语言中const是冒牌货
const int a = 10;
int *p;
//a = 1; //报错
p = &a;
*p = 2; //编译可以通过，但是c++中虽然不报错，但是值改不了

C++中const的原理：
编译器碰见常量时，在符号表中放入常量，编译过程中如果发现使用常量，则直接以符号表中的值替换，编译过程中如果发现对const使用了extern或&操作符，则给对应的常量分配存储空间，但不会使用其存储空间中的值：p = (int*)&a;

const分配内存的时机：编译器编译期间

c++中const用来替换#define
int a = 1;
int b = 2;
int array[a + b]; //C、C++编译器都不通过，但在Linux内核里面是成立的，原因是Linux内核的gcc编译器是支持这种写法的

const int a = 1;
const int b = 2;
int array[a + b]; //C++编译中可以通过，而C编译不能通过

C++中的const是由编译器处理的，而C中的#define是由预处理器处理的，仅仅是文本替换
const定义的变量由编译器处理，提供类型检查和作用域检查
void fun1(){
	#define a 10 //这个#define不仅仅对fun1这个函数起作用，会对整个源文件起作用，如果仅仅想将其限制在本函数内使用，需要在函数结束时加上#undef a，#undef不加参数代表把所有的宏定义都卸载掉
	const int b = 20;
	#undef a;
}





















