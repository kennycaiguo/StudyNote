Solaris是Unix系统的衍生版本

D:\Program Files\gcc\gcc\bin

C:\Program Files (x86)\Java\jdk1.8.0_45\bin;
C:\Program Files (x86)\Java\jdk1.8.0_45\bin;
C:\ProgramData\Oracle\Java\javapath;
C:\Program Files (x86)\Intel\iCLS Client\;
C:\Program Files\Intel\iCLS Client\;
C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;
%SystemRoot%\system32;
%SystemRoot%;
%SystemRoot%\System32\Wbem;
%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;
C:\Program Files (x86)\Windows Live\Shared;
C:\Program Files (x86)\Intel\OpenCL SDK\2.0\bin\x86;
C:\Program Files (x86)\Intel\OpenCL SDK\2.0\bin\x64;
C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;
C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;
C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;
C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;
C:\Program Files\Microsoft\Web Platform Installer\;
C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET Web Pages\v1.0\;
C:\Program Files (x86)\Windows Kits\8.0\Windows Performance Toolkit\;
C:\Program Files\Microsoft SQL Server\110\DTS\Binn\;
C:\Program Files (x86)\Microsoft SQL Server\110\Tools\Binn\;
C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;
C:\Program Files (x86)\Microsoft SQL Server\110\Tools\Binn\ManagementStudio\;
C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE\PrivateAssemblies\;
C:\Program Files (x86)\Microsoft SQL Server\110\DTS\Binn\;
C:\Program Files\nodejs\;
C:\Program Files\MySQL\MySQL Server 5.1\bin

System库函数的功能是执行操作系统的命令或者运行指定的程序
System库函数的调用需要include<stdlib.h>

int main(){
	system("notepad");

	return 0;

}

gcc -o a a.c编译a.c，并自动执行链接，生成a.exe可执行文件
写完整应该是这样gcc -o a.exe a.c，这条指令我们最好写在windows环境下
在Linux环境下写gcc -o a a.c只会生成文件a，不会生成a.out，Linux下没有扩展名这种说法
Linux下也可以写gcc -o a.exe a.c，但是会生成一个a.exe这样一个文件，这样不是很好
windows下执行gcc a.c默认生成a.exe，Linux下执行gcc a.c默认生成a.out，这次生成的a.out是有扩展名的

主函数return 0一般代表成功
return -1代表失败

Linux下写的C语言程序移植到Unix下几乎可以不做任何修改就可以跑
但是Linux或者Unix下的C语言程序在windows上几乎不能跑
windows下写的C语言程序在Linux或Unix下也不能跑

POSIX是一种规范，但是windows对POSIX的支持很差，但是Linux和Unix对其支持非常好

在写代码的过程中尽量调用POSIX里面的函数

C语言的编译过程
1、预编译	.c文件
2、编译
3、链接		可执行文件

Linux下执行指令
预编译-E
gcc -E -o a.e a.c
将会预编译a.c文件，生成a.e文件
打开a.e文件之后翻到最下方，会发现main函数#include没有了，预编译阶段就是要将#include引入的头文件中的东西原封不动的放进来，同时将代码中的注释删除掉

引入头文件时，通过尖括号<>引入代表让C语言编译器去系统目录下寻找相关的头文件，通过双引号引入代表让C语言编译器去用户当前目录下寻找相关文件

汇编-S
gcc -E -o c1.c c.c
gcc -S -o c.s c1.c

演示以下代码的汇编过程
a=1;
b=2;
c=a+b;
__asm加一个大括号就是嵌入一段汇编代码
__asm
{
	mov a,1
	mov b,2
	mov eax,a	将a放入寄存器
	add eax,b	a和b相加，再放入寄存器
	mov c,eax	
}
汇编语言是独立的，汇编语言不跨平台

编译-c
gcc -c -o c.o c.s
-c将代码编译成二进制机器指令

.c文件->预编译->编译->链接->可执行程序

gcc没有任何参数代表就是链接

Qt版本Hello World
新建->项目->Qt Widgets Application->基类 QWidgets
Qt里面是Ctrl+R运行

RISC精简指令集 例如手机系统中的ARM指令集，UNIX中的指令集
CISC复杂指令集 例如PC和笔记本电脑中的x86指令集，Linux是基于x86的操作系统

复杂指令集包含所有的指令，包括常用指令和不常用指令
20%的指令为常用指令，在一个程序执行的时候调用比例达到80%
80%的指令为不常用指令，在一个程序执行的时候调用比例只有20%

精简指令集只包含常用指令，复杂指令需要自己写程序实现

Sun公司有自己的CPU，是基于SPARTC指令集的，其实就是一款RISC的CPU

汇编语言
I386汇编简介
VS反汇编
F9打断点->F5用调试方式运行代码->菜单栏调试->查看汇编语言

操作系统结构
计算机内存分为两个区域，用户区域和内核区域
操作系统、设备驱动程序运行在内核区域
我们自己写的普通程序在用户区域
32位操作系统最大内存为4G，操作系统占用1G，剩下的3G给用户

32位和64位系统区别
CPU内部又可分为运算器、控制器、寄存器
CPU里面有多个寄存器
A B C D是8位寄存器
AX BX CX DX是16位寄存器AX=AH+AL BX=BH+BL CX=CH+CL DX=DH+DL
EAX EBX ECX EDX都是32位寄存器
REAX REBX RECX REDX都是64位寄存器
CPU的寄存器决定了CPU的位数，寄存器位数越大，同一时刻能够寄存的位数越大

32位的CPU不能运行64位的操作系统，因为CPU的计算能力达不到64位
64位的CPU可以运行32位的操作系统，因为可以向下兼容

常量可以通过define和const来定义，此外还有字符串常量

const char *str="hello c";//C++定义了字符串常量

short在32位系统下占2个字节大小
long在32位系统下占4个字节大小，在64位windows系统下是4个字节，UNIX下成了8个字节，但int不论是32位还是64位，不管是windows还是UNIX都是4个字节，所以long尽量少用
long long不论在什么操作系统下都占8个字节大小，对于32位操作系统，CPU寄存器是32位，所以计算long long类型的数据，效率很低

unsigned int占4位

//溢出：
int i1=0x11111111;	//0001 0001 0001 0001 0001 0001 0001 0001
short abc1=-2;		//1111 1111 1111 1110
i1=abc1;		//赋值时会判断abc1值的正负，如果是abc1是正数的话(例如值为2)会赋值为
			//0000 0000 0000 0000 0000 0000 0000 0010
			//如果是负数的话(例如值为-2)会赋值为
			//1111 1111 1111 1111 1111 1111 1111 1110
			//即小值赋给大值时，符号位不会丢失
printf("%x\n",i1);

大端对齐和小端对齐
int a1=0x12345678;
printf("%p\n",&a1);//0030F8E4
但是我们通过查看内存可以看到在0030F8E4这块内存处是
78 56 34 12 cc cc cc cc
看起来好像是倒着放的

对于ARM、Intel这种x86架构的复杂指令CPU，整数在内存中是倒着存放的，低地址放低位(7和8)，高地址放高位(1和2)，这就叫小端对齐
但对于UNIX服务器的CPU，更多是采用大端对齐的方式存放整数

char类型在内存中占一个字节
sizeof(char)得到1

\n是回车加换行的效果
\r是换行
回车是指回到当前行的开头，换行才会到下一行


char a=127;
a=a+5;	//机器会认为1000 0100是一个负数的补码，转换成原码就是1111 1100

float,double,long double

sizeof(float) 4 32位系统
sizeof(double) 8 32位系统
sizeof(long double)

相比于整数，浮点数运算效率很低

volatile代表变量是一个可能被CPU指令之外的地方改变的
volatile int i=100;告诉编译器，不要智能的针对变量i优化代码
例如:
int i;
i=100;
i=i+50;
i=i+20;
//这段代码如果直接编译的话编译器会将其合并，成为
int i;
i=100;
i=i+70;
//但是我们有时候不希望编译器这样给我们智能的操作，这时可以写成
volatile int i;
i=100;
i=i+50;
i=i+20;



int i;
i=100;
i=i+50;
i=i+20;
//上面这段程序如果翻译为汇编语言，即为
__asm{
	mov i,100
	mov eax,i
	//注意这样写是不可以的:add i,50，因为CPU中的运算必须要在寄存器里面进行，所以必须要将内存中的变量放到寄存器当中运算，运算完毕之后再将结果返回给内存
	add eax,50
	mov i,eax
	mov eax,i
	add eax,20
	mov i,eax
}
//但是这段汇编可以优化为
__asm{
	mov i,100
	mov eax,i
	add eax,50,
	add eax,20,
	mov i,eax
}

我们其实还可以通过register关键字来优化变量
register int i;//register修饰了i之后，i就会直接在寄存器里面
i=100;
i=i+50;
i=i+20;
这样一来上面的这段代码在汇编过程中就可以转换为
__asm{
	mov eax,100
	add eax,50
	add eax,20
}
register是建议型的指令，而不是命令型的指令，如果CPU没有寄存器的话这个变量是不会被放入寄存器的

字符串格式化输入输出
字符串是内存中一段连续的char空间，以'\0'结尾

%hd short int
%hu unsigned short int
%f float/double
%p void *以16进制形式输出指针

将l附加在d u x o前代表输出长整数
%6ld
%-6ld 左对齐
%06ld 将前面用0补齐
注意0和-不能一起使用，例如%-06ld这样写会将0的作用忽略掉

putchar(67);//将67的ASCII码打印出来
putchar一次只能显示一个字符，参数也只有一个

在Visual Studio下如果用scanf的话需要，定义一个宏
#define _CRT_SECURE_NO_WARNINGS
或者用
#pragma warning(disable:4996)屏蔽掉VS里面4996这个错误

左值：表示可以被更改的数据对象
右值：能赋给左值的就是右值 右值通常是表达式

int array[2][3];//定义了一个二位数组，一个int的存储空间是4个字节，这个二维数组的存储空间占24个字节
二维数组初始化int array[2][3]={{1,2,3},{4,5,6}};
int array[2][3]={0};//让数组每个值都初始化为0

字符数组
char array[100]={'a','b','c'};//array[3]是0 长度为100
char array[100]="abc";//写法等同于上面
char array[100]={0};//初始化为空串
char array[]="abcd";//长度为5 即sizeof(array)为5
printf("%s\n",array);//abc

字符串逆置
char str[100]="hello world";
int i=0;
while(str[i++]);//i会得到字符串的长度
int min=0;
int max=i-2;
while(min<max){
	char tmp=str[min];
	str[min]=str[max];
	str[max]=tmp;
	min++;
	max--;
}

char str[100]="你好世界";//这里如果还按照上面的方法来的话，就会出现乱码
//因为此处的汉字是GBK编码的
//GBK编码是用两个字节存放一个汉字
//char buf[100]="你";//我们在内存中可以可以看到汉字"你"的存储方式是"c4e3"
//其中c4是一个字节，e3是一个字节
//如果按照上面的方式调换位置就变成了e3c4，所以就出现了乱码
//通过以下程序打印出其长度也可以说明这个问题
char str[100]="你";
int i=0;
while(str[i++]);
printf("%d\n",i);//得到3
//所以汉字的反转代码如下
char s[100]="你好世界";
int len=0;
while(s[len++]);
int min=0;
int max=len-1;
while(min<max){
	char tmp=s[min];
	s[min]=s[max-1];
	s[max-1]=tmp;

	char tmp=s[min+1];
	s[min+1]=s[max];
	s[max]=tmp;

	min+=2;
	max-=2;
}

相同的代码放到Linux下又会出现乱码，因为Linux下的编码是UTF-8，而UTF-8中每个汉字占3个字节




char[5]={0};
int i;
for(i=0;i<5;i++){
	printf("%d\n",i);//会得到一个随机值，所以定义变量的时候最好初始化
}

----------------------
char s[5]={0};
s[0]='a';
s[1]='b';
s[2]='c';
s[3]='d';
printf("%s\n",s);//在这里printf得到的就是一个字符串，因为最后一个字符是0
//但是如果写成下面这样
char s[5]={0};
s[0]='a';
s[1]='b';
s[2]='c';
s[3]='d';
s[4]='e';
printf("%s\n",s);//在这里printf得到的将不再是字符串，而是一个字符数组，程序在读到s的第4个字符的时候发现不是字符串，那么程序将会继续向后读取直到读取到0为止，因此屏幕上除了输出abcde之外后面还会跟一堆乱码

ASCII码用%d输出之后都是正值，GBK和UTF-8表示的汉字第一个字节是负值

混合统计汉字与ASCII字符串字符数量
char buf[100]="你好abc";
int len=0;
int i=0;
while(buf[i]){
	if(buf[i]<0){
		i++;
	}
	i++;
	len++;
}
printf("%d\n",len);

----------------------------------
char s[100]="hello world";
s[4]=0;
printf("%s\n",s);//hell

去掉字符串右边空格
char s[100]="hello world";
int len=0;
while(s[len++]);
len--;//得到长度

int i=0;
//while(s[i]){
//	if(s[i]==' '){
//		s[i]=0;
//		//s[i]='\0';这种写法等价于s[i]=0
//		break;
//	}
//	i++;
//}
for(i=len-1;i>=0;i--){
	if(s[i]!=' '){
		s[i+1]=0;
		break;
	}
}
printf("%s\n",s);

//去掉字符串左边空格
char s[100]="   hello";
int len=0;
while(s[len++]==' ');
len--;
int i=len;
while(s[i]){
	s[i-len]=s[i];
	i++;
}
s[i-len]=0;
printf("|%s|\n",s);

随机数
rand()和srand() 需要引入#include<stdlib.h>
单用rand()是有问题的，需要配合srand()来使用
只要能保证每次调用srand函数的时候，参数的值是不同的，那么rand函数就一定会产生不同的随机数
想要让srand参数的值不同，可以通过传入时间来实现
想要在程序中用时间，必须引入时间库#include<time.h>
time_t tm=time(NULL);
srand(tm);//称为随机数种子发生器
printf("%d\n",rand());

字符串的输入操作
char s[100]={0};
scanf("%s",s);//scanf是以回车作为输入完成的标识，但是回车键本身并不会作为字符串的一部分
//如果scanf参数中的数组长度小于用户在键盘输入的长度，那么scanf就会缓冲区溢出，导致程序崩溃
printf("%s\n",s);

scanf将回车、空格都认为字符串输入结束的标志，可以用gets函数替代它

int main(){
	char s[100]={0};
	gets(s);//gets认为回车输入是结束标识而空格不是
	//gets和scanf一样，也存在缓存区溢出的问题
	int i;
	for(i=0;i<10;i+){
		printf("%d\n",s[i]);
	}
}

char a[100]={0};
char b[100]={0};
gets(a);
gets(b);
int i1=atoi(a);//将字符串转化为一个整数
int i2=atoi(b);//atoi函数需要引入stdlib库
printf("%d\n",i1+i2);

gets不能用类似%s或者%d之类的字符进行转义 只能接受字符串的输入
但scanf可以

scanf和gets都是危险的，fgets函数是安全的
fgets(s,100,stdin);参数分别是char数组 数组缓冲区大小 标准输入
调用fgets的时候只要能保证第二个参数小于数组实际的大小那么就可以避免缓冲区溢出的问题
第二个参数通常可以写成sizeof(s)-1

puts函数和printf类似，用来打印字符串
char s[100]={"hello world"};
puts(s);//puts函数自动会输出完成之后打印一个'\n'

fputs是puts的文件操作版本
char s[100]={"hello world"};
fputs(s,stdout);

字符串操作库函数 需要引入string.h
int main(){
	char s[100]="hello world";
	int len=strlen(s);//这个长度不包含结尾的\0

	//很多函数如果确认不会返回小于0的值，那么就会使用size_t类型，例如strlen sizeof就是返回size_t类型的，size_t其实就是unsigned int

	char s1[100]="abc";
	strcat(s,s1);//这个函数需要加上忽略安全检查宏定义
	//之所以要加忽略安全检查，是因为当s的长度很小而s1很大时，将s1全部追加到s后面，s会放不下
	//strncat可以取代strcat这个方法从而规避安全的问题，例如strncat(s,s1,6);只将s1的6个字符追加给s
	printf("%s\n",s);

	//strcmp 字符串比较
	//注意：不能通过str1==str2来比较字符串
	if(strcmp(s1,s2)==0){//如果strcmp的返回值为0，代表参数中的两个字符串内容相同，反之不相同
		printf("s1和s2相同");
	}

	//strncmp(s1,s2,5)比较s1和s2的前5个字符

	//strcpy(s1,s2);将s2的内容拷贝到s1 条件是s2的长度一定要小于s1

	//char s1[100]="123456";
	//char s2[100]="abcdef";
	//strncpy(s1,s2,3);将s2的前三个字符拷贝到s1 s1变成了abc456 即只有前三个字符被覆盖了 后面的字符没有被覆盖

	//int i=100;
	//sprintf(s,"i=%d",i); 将格式化后的字符串赋给s 执行完这条语句后字符串s就变成了"i=100"

	sprintf(s,"%d",i);//将整型的i转变为字符串赋给s
	//注意：atoi是将字符串转换为整型 虽然有itoa这个函数 但itoa()不是标准C语言库函数 但是atoi()是标准的C语言库函数

	char s[100]="5+6=";
	int a=0;
	int b=0;
	sscanf(s,"%d+%d",&a,&b);//比scanf多了一个参数，a和b就对应5和6，意思就是将5和6赋值给a和b
	printf("%d\n",a+b);

	//注：字符串初始化完成之后就不可以再通过等号赋值了
	//例如：char s[100]="abcdef";
	//s="ghijkl"; 这样做是错误的
	//可以通过strcpy来赋值 strcpy(s,"ghijkl");

	const char *buf=strchr(s,'o');//返回一个指针 strchr(s,'o');代表在s这个字符串中间查找第二个参数指定的字符，如果找到的话返回从该字符开始往后的字符串，找不到返回null
	printf("%s\n",buf);

	buf=strstr(s,"ll");//功能和返回值类似strchr 注意第二个参数是字符串，而不是字符，将返回"ll"后面的部分，包含"ll"
	strcpy(s,"abc_def_ghi");//如果希望返回abc def ghi，即以_为分隔符
	buf=strtok(s,"_");
	printf("%s\n",buf);//abc
	buf=strtok(NULL,"_");//第二次调用的时候第一个参数要传为NULL
	printf("%s\n",buf);//def
	buf=strtok(NULL,"_");
	printf("%s\n",buf);//ghi

	//将上述代码用循环代替
	buf=strtok(s,"_");
	while(buf){
		printf("%s\n",buf);
		buf=strtok(NULL,"_");
	}

	//atoi 将字符串转换成整数 需要引入stdlib库函数
	//atof
	//atol
	char s[100]="200";
	int i=atoi(s);
	printf("i=%d\n",i);
}


//字符串转换成整型 类似parseInt
//1 要知道字符串有多长
//2 将字符串每个字符读取出来 转换为整数后 乘以10的 长度减1次方
//3 将每个位计算和加起来就是转化后的结果
char s[100]={'5','8','1'};
int len=0;
while(s[len++]);
len--;

int value=0;
int i=0;
int tmp=len;  //3
for(i=0;i<len;i++){
	int base=10;
	if((tmp-i-1)==0){
		base=1;
	}else{
		int j;
		for(j=1;j<tmp-i-1;j++){
			base*=10;
		}
	}
	value+=(base*(s[i]-'0'));
}

==========================
int main(){
	char str1[100]="hello";
	test_str(str1);
	printf("%s\n",str1);//abllo
	return 0;
}
void test_str(char s[]){
	s[0]='a';
	s[1]='b';
}

=========================多文件编译
#include "abc/b.h" 引入相对于当前目录下的abc文件夹下的b.h

不允许用任何库函数，将整数转换成字符串
void myitoa(int n,char s[]){
	int status=0;//0代表正数，1代表负数
	if(n<0){
		status=1;
		n=0-n;
	}
	int i=0;
	while(n){
		int a=n%10;//取出整数的个位
		char c=a+'0';//将整数转化为字符
		s[i]=c;//将转化后的char依次放入字符串s中
		i++;
		n/=10;
	}
	int min=0;
	int max=i-1;
	while(min<max){
		char tmp=s[min]
		s[min]=s[max];
		s[max]=tmp;
		min++;
		max--;
	}
	if(status==1){//负数
		int len=0;
		for(len=i-1;len>=0;len--){
			s[len+1]=s[len];
		}
		s[0]='-';
	}
}
int main(){
	int i=456;
	char s[100]={0};
	myitoa(i,s);
	printf("");
}

写一个头文件供别的文件引用时，一定要加上#ifndef和#endif，否则，当我们多次预编译主文件过后，函数的声明就会引入多次
#ifndef __AH__ //如果没有__AH__这个宏，就编译#ifndef __AH__和#endif之间的代码，如果有的话就不编译了
#define __AH__ //具体宏的名字是自定义的
int max(int a,int b);
int add(int a,int b);
#endif

define定义的宏，习惯大写加下划线

==============10进制转换为2进制
void bin(int n){
	int i=n%2;
	if(n>0){
		bin(n/2);
		printf("%d\n",i);//后续递归
	}
}

==============10进制转换为16进制
void hex(int n){
	int i=n%16;
	if(n>0){
		bin(n/16);
		printf("%c\n",hex1(i));//后续递归  hex1函数主要处理大于9的数，对于小于等于9的数，直接输出对应字符串
	}
}

==============通过递归的到字符串长度
int mystrlen(char s[],int n){
	if(s[n]){ //当循环到字符串最后的\0时，条件为假
		return mystrlen(s,s[n+1]); //这里如果不加return的话VS编译器有可能会有警告
	}else{
		return n;
	}
}
调用的时候通过mystrlen("aaa",0);

内存的最小单位是byte，每个byte的内存都有一个唯一编号，这个编号就是内存地址，编号在32位系统下是一个32位的整数
在64位系统下是一个64位的整数

==指针
char buf[10];
printf("%u %u %u %u",buf,&buf[0],&buf[1],&buf[2]); //buf和&buf[0]

如果写成int p=&a;语法上没有错误，但是地址是一个特殊的整数，是不能通过整数来操作的，所以要定义成int *p=&a;
int *p1;//定义一个变量，名字叫p1，它可以指向一个int的地址

无类型指针：void *p; 意思是这只是一个指针变量，不指向任何具体的数据类型

printf("%d",sizeof(p2)); //4 32位操作系统下永远都是4(64位下是8)，和p2这个指针指向什么类型没有关系

void *p3;//目前p3没有任何变量的地址所指向，叫野指针
p3=NULL;//将指针赋值NULL，值为NULL的指针，我们俗称空指针
NULL其实就是0，下面的代码输出为false
if(p3){
	printf("true");
}else{
	printf("false");
}


int *p1;//初始化的时候没有赋值，p1就是一个野指针 程序中要避免野指针的存在 野指针是导致程序崩溃的主要原因
*p1=3;//对未知的空间读写计算机会被认为是恶意行为，虽然编译时没有问题，但运行时会阻止

指针兼容性
int a=0x1310;
char *p=&a;//会报类型不兼容的警告
printf("%x\n",*p);//10 即只读到了低8位
=========================================
char b=2;
int *p=&b;
printf("%x\n",*p);//cccccc02 因为一定要输出4个字节才可以构成一个int值，因此前3个字节就变成了随机值
=========================================
char buf[10]={0x12,0x34,0x56,0x78,0x90};
int *p=buf;
printf("%x\n",*p);//78563412 只输出前4个字节
=========================================
float f=3.14;//float占4个字节
char *p=&f;
printf("%x,%x,%x,%x",*p,*(p+1),*(p+2),*(p+2));//ffffffc3,fffffff5,48,40

原则上一定是相同类型的指针指向相同类型的变量地址

指针常量与指向常量的指针
int main(){//定义一个指向常量的指针
	int a=10;
	const int *p=&a;//p这个指针只能指向一个常量
	*p=20;//会报错 不能通过*p的方法修改一个const指针
	//但是可以改a
	printf("a=%d\n",a);
}
//但在C语言中，实际上通过间接的方式仍然可以修改，所以C++修正了这个问题
int main(){
	int a=100;
	const int *p=&a;
	int *p1=p;
	*p1=10;
	printf("a=%d\n",a);//10 C语言里面可以这样改，但是C++里面是不可以这样改的
}

int main(){//常量指针
	int a=10;
	int b=30;
	int *const p=&a;//定义一个常量指针，可以通过常量指针修改或者读取一个变量的值
	*p=20;//可以赋值
	//但是p=&b;会报错 常量指针一旦定义了就不能修改其指向的变量
	printf("a=%d",*p);//可读
}

指针与数组
int main(){
	char buf[10]={0,1,2,3,4};
	char *p=buf;
	char *p=&buf;//buf &buf &buf[0]都是数组第一个元素的地址
	char *p1=&buf[0];
}
================
char buf[10]={0,1,2,3,4}; //sizeof(buf)是10
char *p=buf;
int i;
for(i=0;i<10;i++){
	*p=i;
	p++;
	//注意不可以写成buf++ buf是数组名，数组名是一个指针常量
}
print(buf);
//此时p已经指向数组的最后一个成员，此时再p++就会越界，所以需要重新改变p的值
p=buf;//将p的值重新指向了数组的首地址
p-=10;//将p的值重新指向了数组的首地址
=================
int[10] p={1,2,3,4,5,6,7,8,9,0};
p+=7;//现在p指向了第7个元素
p[2]=100;//这里将不再是给第2个元素赋值了，因为p[2]相当于*(p+2)，所以这里的p其实指向了第9个元素
=================
int main(){
	int a=0x12345678;//整形占4个字节
	char *p=&a;
	p++;
	printf("%x\n",*p);//56 输出是56，证明整数在内存中存储的方式是大端对齐模式
	//大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中
	//小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中
}
int main(){
	int a=0x12345678;//整形占4个字节
	char *p=&a;
	p++;
	p++;
	printf("%x\n",*p);//34
}
int main(){
	int *p1=&arr[2];
	int *p2=&arr[5];
	printf("%d\n",p2-p1);//3
}
=================IP地址的保存
"192.168.1.2"
"234.213.222.231"
IP地址在网络中传递的时候是一个DWORD，就是一个int
int main(){
	int ip=0;
	unsigned char *p1=&ip;
	*p1=192;
	p1++;
	*p1=168;
	p1++;
	*p1=6;
	p1++;
	*p1=252;
	printf("%d\n",ip);
	//将整数转化为ip
	ip2s(ip);
	//将ip字符串转换为整数
	char s[100]="192.168.1.251";
	int my_ip=s2ip(s);
}
void ip2s(int n){
	char *p=&n;
	unsigned char *p=&n;
	printf("%d.%d.%d.%d\n",*p,*(p+1),*(p+2),*(p+3));
}
void s2ip(char s[]){
	int a=0;
	int b=0;
	int c=0;
	int d=0;
	sscanf(s,"%d.%d.%d.%d",&a,&b,&c,&d);
	//printf("a=%d,b=%d,c=%d,d=%d",a,b,c,d);
	int ip=0;
	char *p=&ip;
	*p=a;
	p++;
	*p=b;
	p++;
	*p=c;
	p++;
	*p=d;
	p++;
	return ip;
}

用指针求一个字符串的长度
char s1[100]="hello";
char s2[100]="world";
char *p1=s1;
int len=0;
while(*p1){//*p1的内容为0的时候表示字符串结束了 *p1=='\0'
	p1++;
	len++;
}

char *p2=s2;
while(*p2){
	*p1=*p2;//当前p1已经指向s1的最末尾，从s1的最后开始，从s2的首元素开始
	p2++;
	p1++;
}
//while循环里面的代码可以简化为*p1++=*p2++;
printf("s1=%s\n",s1);//helloworld

=============================
int buf[10];
int *pp1=&buf[1];
int *pp2=&buf[3];
printf("%d\n",pp2-pp1);//2

==========================
void bubble(int *s){
	int i;
	int j;
	for(i=0;i<10;i++){
		for(j=1;j<10;j++){
			if(*(s+j)>*(s+i)){
				int tmp=*(s+j);
				*(s+j)=*(s+i);
				*(s+i)=tmp;
			}
		}
	}
}
=========================
数组逆置
int *start=&buf[0];
int *end=&end[9];
while(start<end){
	int tmp=*start;
	*start=*end;
	*end=tmp;
	start++;
	end--;
}

不排序求数组第二大元素
int smax(int *s){
	int max=*s;
	int s_max=*(s+1);
	if(s_max>max){
		max=*(s+1);
		s_max=*s;
	}
	for(int i=2;i<10;i++){
		if(max<*(s+i)){
			s_max=max;
			max=*(s+i);
		}else if(*(s+i)<max && *(s+i)>s_max){
			s_max=*(s+i);
		}else{
			//比s_max还要小，什么都不用做
		}
	}
	return s_max;
}

通过指针逆置单词
char str[100]="you good me too";
char *str_start=&str[0];
char *str_end=&str[strlen(str)-1];
while(str_start<str_end){
	char *tmp=*str_start;
	*str_start=*str_end;
	*str_end=tmp;
	str_start++;
	str_end--;
}
printf("%s\n",str);

通过指针逆置汉字字符串，一个汉字是两个字节
char str[100]="你好我也好";
short *str_start=&str[0];//short类型是2个字节
short *str_end=&str[strlen(str)-2];
while(str_start<str_end){
	short *tmp=*str_start;
	*str_start=*str_end;
	*str_end=tmp;
	str_start++;
	str_end--;
}
printf("%s\n",str);

===================
指针数组
int *a[10];//定义了一个指针数组，一共10个成员，其中每个成员都是int *类型
printf("%d,%d\n",sizeof(a),sizeof(a[0]));//40 4
sizeof(a)是a里面所有值的长度的和，一个int *占4个字节，10个自然就是40个字节
sizeof(a[0])是第0个元素的长度，第0个元素是一个int *类型，占4个字节

short *b[10];
printf("%d,%d\n",sizeof(b),sizeof(b[0]));//40 4
不论什么类型的指针类型，地址本身只占4个字节

二级指针
int a=10;
int *p=&a;
int **pp=&p;
**pp=100;
=======================================
指向二维数组的指针
int main(){
	int buf[2][3]={{1,2,3},{4,5,6}};
	//int *buf[3];指针数组
	int (*p)[3];//定义了一个指针，指向int [3]这种数据类型，这就是指向二维数组的指针
	printf("%d\n",sizeof(p));//4
	p=buf;//p指向了二维数组中的第一行
	p++;//p指向第二行
	printf("%d,%d\n",p,p+1);//3276484 3276496 相差12 位移了1*sizeof(int [3])
	printf("%d,%d\n",p,p+2);//3276496 3276520 相差24 位移了2*sizeof(int [3])
	int i;
	int j;
	for(i=0;i<2;i++){
		for(j=0;j<3;j++){
			printf("%d\n",p[i][j]);
		}
	}
	for(i=0;i<2;i++){
		for(j=0;j<3;j++){
			printf("%d\n",*(*(p+i)));//*(p+i)是第i行首元素的地址 *(*(p+i))是第i行首元素地址的值
			printf("%d\n",*(*(p+i)+j));//*(p+i)+j是第i行第j个元素的地址，*(*(p+i)+j)是第i行第j个元素的值，等价于p[i][j]
		}
	}
}

int buf[3][5];
int (*a)[5];			定义一个指向int[5]类型的指针
a				第0行的首地址
a[0],*(a+0),*a;			第0行第0个元素的地址
a+1;				第1行的首地址
a[1],*(a+1);			第1行第0个元素的地址
a[1]+2,*(a+1)+2,&a[1][2]	第1行第2个元素的地址
*(a[1]+2),*(*(a+1)+2),a[1][2]	第1行第2个元素的值

int buf1[3][5]={{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}};
//通过指针求每行每列的平均值
//可以先考虑不用指针的情况
for(int i=0;i<3;i++){
	int sum=0;
	for(int j=0;j<5;j++){
		//sum+=buf1[i][j];
		sum+=*(*(buf1+i)+j);
	}
	printf("%d\n",sum/5);//每行的均值
}
for(int i=0;i<5;i++){
	int sum=0;
	for(int j=0;j<3;j++){
		//sum+=buf1[j][i];
		sum+=*(*(buf1+j)+i);
	}
	printf("%d\n",sum/3);//每列的均值
}
=======================================
void set_array(int *buf,int n){//这种写法同void set_array(int buf[]){...} n主要是用来告诉函数内部buf这个数组的维度
	printf("%d\n",sizeof(buf));//4
	buf[0]=100;//等价于*buf=100
}
int main(){
	int buf[5]={1,2,3,4,5};
	printf("%d\n",sizeof(buf));//20
	set_array(buf,sizeof(buf)/sizeof(int));
}
=======================================
void print_array(int (*p)[3],int a,int b){//等价于int p[][3] 将二维数组作为函数参数传递的时候定义的指针类型 平时开发用的很少
	int i;
	int j;
	for(i=0;i<a;i++){
		for(j=0;j<b;j++){
			printf("p[%d][%d]=%d\n",i,j,p[i][j]);
		}
	}
}
int main(){
	int buf[2][3]={{1,2,3},{4,5,6}};
	print_array(buf,sizeof(buf)/sizeof(buf[0]),sizeof(buf[0])/sizeof(int));
}
==========================
void mystrcat(char *s1,const char *s2){//第一个参数是要被修改的，第二个参数不被修改
	int len=0;
	while(s2[len]){
		len++;
	}
	while(*s1){
		s1++;
	}
	int i;
	for(i=0;i<len;i++){
		*s1=*s2;
		s1++;
		s2++;
	}
}
int main(){
	char s1[10]="abc";
	char s2[10]="def";
	mystrcat(s1,s2);
	printf("s1=%s\n",s1);
	return 0;
}

strcpy在定义的时候是这样的：strcpy(char *s1,const char *s2);因为s2不需要改变，所以需要用const保护起来
=============================
返回指针类型的函数
char *mystrchr(char *s,char c){
	while(*s){
		if(*s==c){
			return s;
		}
		s++;
	}
	return NULL;
}
int main(){
	char str[100]="hello world";
	char *s=mystrchr(str,'o');
	printf("s=%s\n",s);//o world
}
================================
char *mystrstr(char *s,const char *str){//在s中查找相关的子串

}
==============================
函数指针 Java中的多态在底层就是通过函数指针来实现的
int add(int a,int b){
	return a+b;
}
int max(int a,int b){
	return a>b?a:b;
}
int main(){
	int(*p)(int,int);//定义了一个指向函数的指针，但是函数必须要有两个参数，而且返回至必须也是int，在C++中是编译不通过的，不过在C语言中只有警告
	p=add;
	int i=0;
	i=p(5,7);
	printf("%d",i);//12
	p=max;
	int j=0;
	j=p(5,7);
	printf("%d",i);//7
	return 0;
}

//定义一个参数为int * 返回值为int *的指向函数的指针
int *(*p)(int *);

===================================
把指向函数的指针作为函数的参数
void function(int(*p)(int,int),int a,int b){//第一个参数是指向函数的指针
	return p(a,b);
}
int main(){
	int i=func(add,6,9);//add就是回调函数
	printf("i=%d\n",i);
	return 0;
}
==================================
内存操作函数――memset 需要引入string.h头文件
int buf[10]={0};//int buf[10]={0}这种数组赋值方式只能用于定义数组的时候同时初始化内容，不能在中途调用
buf[0]=8;
buf[1]=9;
buf[2]=8;
//希望将这个buf再一次初始化为0
//在这里如果企图通过buf[10]={0}来重新把所有的值都重置为0是不可以的，这种方式只能在初始化的时候用
memset(buf,0,sizeof(buf));//三个参数分别是要设置的内存地址 要设置的值 内存大小

===================================
内存操作函数――memcpy
int main(){
	int buf1[5]={1,2,3,4,5};
	int buf2[5];
	memcpy(buf2,buf1,sizeof(buf1));//将buf1的内存内容全部拷贝到buf2，拷贝大小由第三个参数确定，单位是字节
}
====================================
内存操作函数――memmove
int main(){
	int buf1[5]={1,2,3,4,5};
	int buf2[5];
	memcpy(buf2,buf1,sizeof(buf1));
	for(int i=0;i<5;i++){
		printf("%d ",buf2[2]);//1 2 3 4 5
	}
	for(int i=0;i<5;i++){
		printf("%d ",buf[2]);//1 2 3 4 5
	}
}
memmove并没有改变原来内存的值，和memcpy功能一样

使用memcpy的时候要确保内存没有重叠区域
int main(){
	int buf[10]={1,2,3,4,5,6,7,8,9,0};
	int *start=buf+3;
	int *end=buf+5;
	memcpy(start,end,16);//将从start首地址开始的16个字节的内容拷贝到从end首地址开始的16个字节内，这样的话在拷贝的过程中就会产生重叠区
}
==============================
字符指针和字符串
int main(){
	char buf[100]="hello world";
	char *p=buf;
	*(p+5)='a';//*(p+5)和p[5]效果是一样的
	printf("%s",buf);
	return 0;
}
============================
void print_str(char *s){//如果是int类型的数组的话(即int*)，那就必须传入第二个参数作为数组的长度，如果是char *就不用，因为字符串是明确的以'\0'结尾的，所以在函数内部是有条件来作为循环终止依据的，但是这同样带来一个问题，那就是如果我们写了s[3]=0这样一句代码，那么用这个print_str函数打印字符串的时候只能打印到第二个字符，第三个字符之后就出不来了，因为循环已经结束了，即使我们不用自定义的函数而用系统提供的printf效果也是一样的，但是字符数组第3个字符后面的字符还真实存在
	int i;
	while(s[i]){
		printf("%c",s[i++]);
	}
}
int main(){
	char s[100]="hello";
	print_str(s);
}
================================
main函数中有参数的情况 操作系统会自己调用main
int main(int argc,char *args[]){
	printf("%d",argc);//1 形参argc代表程序执行的时候有几个参数，程序名称本身就是一个参数，所以argc最小是1
	//第二个参数是一个指针数组，其中每个成员的类型是char*
	//argc就是args的长度
	printf("args[0]=%s\n",args[0]);//可执行程序的绝对路径
	int i;
	for(i=0;i<argc;i++){
		printf("args[%d]=%s\n",i,args[i]);
	}
}
==================================
cmd下运行下面这个程序，效果和dir指令是一样的，但是dir指令有参数，例如dir c: 但是这里的参数不起作用，我们可以将这个程序改造一下
int main(int argc,char *args[]){
	system("dir");
	return 0;
}
================================
int main(int argc,char *args[]){
	char buf[100]="dir";
	int i;
	for(i=1;i<argc;i++){
		strcat(buf," ");
		strcat(buf,args[i]);
	}
	system("dir");
	return 0;
}
==========================
//指针复习
int main(){
	int *s[10]={0};
	int (*p)[10]=0;//定义了一个指针变量p，指向int [10]这么大的一种数据类型
	printf("%d",sizeof(s));//40 s是一个数组名，数组的类型是int *，每个int *是4个字节，所以sizeof(s)是40个字节
	printf("%d",sizeof(p));//4
}
===========================
int main(){
	int array[3][4]={0};
	//int *p=array;这样写是错误的，int *这种类型只能指向一维数组，这里需要int [4]类型，即通过int (*p)[4]来定义
	
}
==============================
内存管理
C语言变量的作用域可以是块级作用域 函数作用域 文件作用域
#include<stdio.h>
int a=10;//全局作用域
int main(){
	printf("%d",a);//10
}
=======================
extern int age;//名为age的int类型的变量在其他外部文件中已经定义过了
=======================
假如在一个工程下有两个C源文件:a.c main.c
//a.c--------------------
int mymax=5;
int max(int a,int b){
	return a>b?a:b;
}
//main.c----------------------------
#include<stdio.h>
int max(int a,int b);//在main.c中引入的时候可以加上extern，也可以不加，只要在这里声明了max函数就把外面a.c文件里面的max函数引过来了
int mymax;//在这里可以用extern修饰，也可以不用extern修饰，但是如果不用extern修饰的话容易让人认为是定义了一个全局变量，但是实际上表示的却是一个外部变量，这样就会有二义性
int main(){
	return 0;
}
---------------------------------
=======================
//a.c--------------------
static int mymax=5;
int max(int a,int b){
	return a>b?a:b;
}
//注：C语言中很少用static修饰max函数
//main.c----------------------------
#include<stdio.h>
int max(int a,int b);
int mymax;//a.c中已经通过static修饰了，main.c里面就无法访问到了，所以这里会报错
int main(){
	return 0;
}
=======================
auto int a1和int a1效果一样
===================
register寄存器变量
register int i=0;//建议如果有寄存器空闲，那么这个变量就放到寄存器里面使用，可以使效率增加
int *p=&i;//这样会报错，既然变量都到寄存器里面了，不存在内存地址这一说，所以寄存器变量不能取地址
==================
void mystatic(){
	static int a=0;//静态变量只初始化一次，而且程序运行期间内，静态变量一直存在，但是这个a的作用域仍然是这个块语句，
	printf("a=%d\n",a);//依次输出0 1 2 3 4
	a++;
}
int main(){
	for(int i=0;i<5;i++){
		mystatic();
	}
}

全局静态变量只能在本文件内使用，在其他文件中即使通过extern引入也不能使用

C语言里面的函数都是全局的
函数也可以用static修饰，加了static的函数只能在当前.c文件中使用

每个应用程序都会占一块独立的内存，各个应用程序之间的内存不能相互访问，对于每个应用程序占的内存，分为堆 栈 代码区 静态区
代码区：程序被操作系统加载到内存的时候，所有可执行代码都被加载到代码区，也叫代码段，这块内存是不可以在运行期间修改的，注意：变量的定义不是可执行代码，变量的赋值是可执行代码
静态区：所有的全局变量以及程序中的静态变量都存储到静态区
栈区：所有的自动变量，函数的形参都是由编译器自动放入栈中，当一个自动变量超出其作用域时，自动从栈中弹出，大小并不固定，各个操作系统下不一样，但是不会特别大，一般以K为单位，所谓栈溢出，就是当栈空间已满，但还往栈内存中压变量，就是栈溢出

#include<stdio.h>
int c=0;//在静态区
void test(int a,int b){
	printf("%d %d\n",&a,&b);
}
int *geta(){
	int a=100;
	return &a;
}
int main(){//函数都在代码区
	int *p=geta();//这里得到了一个临时栈变量的地址，这个地址在函数geta调用完成之后已经无效了，所以这样写可能是有问题的，不符合栈的要求
	*p=100;
	printf("%d\n",*p);
	static int d=0;
	int a=0;//在栈区
	int b=0;
	printf("%d %d %d %d %d\n",&a,&b,&c,&d,main);//从得到的结果可以看出，c与a b的位置相差很远，main函数的地址也没有和a b c挨着，而a和b是挨着的，c和d是挨着的，从a和b的值上可以看到一个细节：a的地址比b大
	test(a,b);//函数里面形参的地址是a的地址比b大
	return 0;
}
以上程序执行的过程中，先定义a，所以a先入栈，再定义b，b再入栈，a就在b的后面，所以a的地址比b大
main函数执行完的时候b先出栈，a后出栈
自动变量的出入栈是编译器控制的，程序无需控制

int main(){
	char array[1024 * 1024 *100]={0};//定义了一个100M的数组，会发生栈溢出，定义一个很大的数组一定会溢出
	return 0;
}

对于32位操作系统，最大管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序的，一个用户程序理论上可以使用3G的内存空间

堆区和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序
堆是一个大容器，它的容量要远远大于栈，但是在C语言中堆内存空间需要手动通过代码申请和释放

malloc和free需要引入stdlib头文件
malloc返回一个无类型的指针(void *)，通常会强转为对应类型，malloc在堆中间申请内存
int *p=(int *)malloc(sizeof(int)*10);
char *p1=(char *)malloc(sizeof(char)*10);//在堆中申请了10个char类型大小的空间
free(p);
free(p1);//释放malloc分配的内存
malloc和free一定要成对使用
返回的p p1可以当指针和数组用
=============
通过memset清空p的内存
memset(p,0,sizeof(int)*10);

int *p=(int *)malloc(sizeof(int)*10);//堆数组
int array[10]={0};//栈数组

上面的geta函数我们可以这样修改使其正确
int *geta1(){
	int *p=malloc(sizeof(int));
	return p;
}
int *geta2(){//这样也可以
	static int a=0;
	return &a;
}
int main(){
	int *getp=geta1();
	*getp=100;
	free(getp);//一定要记得free

	int *getp2=geta2();
	//静态区的变量不能free
}
=============================
void getheap(int *p){
	p=malloc(sizeof(int)*10);
}//getheap执行完以后，p变量就消失了，导致它指向的具体堆空间的地址编号也随之消失了，这里面malloc申请的内存将永远无法释放，main函数里面的free只是释放一个空指针p
int main(){
	int *p=NULL;
	getheap(p);
	p[0]=1;//程序会崩溃
	p[1]=2;
	printf("%d %d",p[0],p[1]);
	free(p);
	return 0;
}
==============可以通过二级指针修改上面的代码
void getheap1(int **p){
	*p=malloc(sizeof(int)*10);
}
int main(){
	int *p=NULL;
	getheap(&p);//将p在栈中的地址传了进去
	p[0]=1;
	p[1]=2;
	printf("%d %d",p[0],p[1]);
	free(p);
	return 0;
}
====================
char *getstring(){//错误的模型
	char array[10]="hello";//因为array是在栈中的地址，但是getstring执行完了之后array所占的空间就会被释放，所以main函数中s变量接受到的是个垃圾值
	return array;
}
int main(){
	char *s=getstring();
	printf("%s",s);
	return 0;
}
======================
int *getheap2(){//正确的模型
	return malloc(100);//返回了一块堆空间的地址，这块地址还没有被释放，所以在main函数中可以拿到
}
int main(){
	int *p=NULL;
	p=getheap2();
	free(p);
	return 0;
}
======================
char getstring1(){//正确的模型
	char c='a';
	return c;
}
int main(){
	char c=getstring1();
	printf("%c",c);
}
======================
const char *getstring3(){//正确的模型
	return "hello";//常量 全局变量 静态变量都在静态区，直接返回常量"hello"的地址是可以的，而且这个常量的地址在程序运行过程中是不变的
}
int main(){
	const char *ss=getstring3();
	printf("%s",ss);
}
======================
char *getstring3(){//正确的模型
	static char array[10]="hello";//在静态区
	return array;
}
int main(){
	const char *ss=getstring3();
	printf("%s",ss);
}
======================
//------------------a.c
//全局变量加了static的话该变量只能在a.c本文件里面使用，而别的文件还可以定义mymax这个变量，但是别的文件里面定义mymax这个变量的时候最好也用static修饰，这样各个文件之间就互不影响了，而在C++中则采用namespace来避免命名冲突
static int mymax=100;//虽然在别的文件里面访问不到mymax变量，但是我们可以通过定义下面的get_mymax来拿到其地址
int *get_mymax(){
	return &mymax;
}
void print_mymax(){
	printf("mymax=%d\n",mymax);
}
-----------------
//------------------main.c
#include<stdio.h>
extern int *get_mymax();
extern void print_mymax();
int main(){
	int *p=get_mymax();
	&p=300;
	print_mymax();//300
	return 0;
}
======================
想要定义动态数组通过下面的方法在栈上定义是不可以的，这样写编译都不会通过，数组在定义的时候长度必须是常量
int i=0;
scanf("%d",&i);
int array[i];
==========================
定义动态数组只能在堆上定义
int i=0;
scanf("%d",&i);
int *arr=malloc(sizeof(int)*i);//使用完了之后可以free掉

C语言中函数的入栈是从右往左的，例如：UpdateCounter(char *b,int c,int a1)这个函数的参数入栈的顺序其实是先a1入栈，接下来c入栈，最后是b入栈，有的高级语言是从左往右入栈的	
======================
操作系统在管理内存的时候，最小单位不是字节，而是内存页
Linux下内存页是4K
当通过malloc申请1K内存时，堆空间大小是4K，再申请1K内存时，堆空间大小还是4K，直到malloc申请到的内存超过4K时会再分配一个4K的内存，这个4K的内存就是内存页，Linux将内存页定为4K一定有它的道理，如果内存页分配太大，那一定回造成空间的浪费，但是操作系统分配内存的次数少了，效率提升，相反内存页分配太小的话，操作系统就需要频繁调度寻找是否有空闲内存，造成效率上的降低，但是节省了空间，所以这是一个折中的问题
在Windows中，我们把一个含有用malloc申请堆空间的C语言程序跑起来以后可以看一下任务管理器进程里面这个程序所占的内存空间，然后改变源代码中malloc申请空间的大小，再看进程所占的空间，就可以计算出Windows下内存页的大小了，代码如下
while(1){
	int *p=malloc(1024);//通过测试发现32位Windows操作系统的内存页也是4K
	getchar();
}
在嵌入式开发的场合一定要节约内存
=====================
malloc申请到的内存空间里面旧的值有可能还保留着，所以我们需要手动调用memset清除，这一步工作可以交给calloc函数，calloc函数保证了申请到的内存空间是干净的，同样也需要free释放内存
char *p1=calloc(10,sizeof(char));//分配了10个大小为sizeof(char)的堆内存，即10个字节

int *p1=calloc(sizeof(int),100);//申请100字节内存
int *p2=realloc(p1,sizeof(int)*200);//再在p1后面申请100字节内存，达到200字节
//新申请的100字节不是空的，可以通过memset(p2+100,0,sizeof(int)*100);来清零

char *p2=realloc(p1,20);//希望申请20个字节，而且希望紧接在p1后，如果p1后面没有连续空间扩展，会新分配一个空间，将原有内存拷贝到新空间，然后释放原有的内存，realloc分配到的内存不是干净的

char *p2=realloc(NULL,5);//分配形式相当于malloc

所有的变量都是在栈里面的，可以通过在栈中存放地址来访问堆内存
calloc的两个参数写反了也无所谓，因为calloc内部其实是把两个参数一乘，再返回结果

不论malloc calloc realloc，都会有一种情况，就是没有堆内存可分配了，申请不到内存空间了，这种情况是比较严重的，可以直接exit(0);
if(p1==NULL){
	exit(0);
}
=====================结构体
#include <stdio.h>
#include <string.h>
#pragma warning(disable:4996)
struct student{
	char name[100];
	int age;
	int sex;
};//说明了一个结构体的数据成员类型
int main(){
	struct student st;//定义一个结构体变量st
	st.age=20;
	st.sex=0;
	strcpy(st.name,"myj");
	printf();
	return 0;
}
-------------初始化方式二
定义结构体的时候就可以初始化
struct student st={"myj",24,0};
struct student st={0};//将所有成员值初始化为0，字符串将会初始化为空串
--------------初始化方式三
scanf("%s",st.name);
scanf("%d",&st.age);
scanf("%d",&st.sex);
-------------初始化方式四
struct student st={.age=20,.name="myj3",.sex=0};
struct student st={.name="myj3",.sex=0};//没有给age初始化，默认为0
-------------初始化方式五
struct student st;
memset(&st,0,sizeof(st));
===================结构体内存对齐模式
struct A{
	int a;
	char b;
};
int main(){
	struct A s;
	printf("%d",sizeof(s));//8 计算长度的时候会以所有成员里面最长的那个为基准
}
--------------
struct A{
	int a;
	char b;
	char c;
	char d;
	char e;
};
int main(){
	struct A s;
	printf("%d",sizeof(s));//还是8
}
-----------------
struct A{
	int a;
	char b;
	char c;
	char d;
	char e;
	char f;
};
int main(){
	struct A s;
	printf("%d",sizeof(s));//12
}
-------------
struct A{
	char a[10];
	char b;
	char c;
	char d;
	char e;
	char f;
	char g;
};
int main(){
	struct A s;
	printf("%d",sizeof(s));//16 只会把数组中的一个元素当成一个成员
}
-----------
struct A{
	char int[10];
	char b;
	char c;
	char d;
	char e;
	char f;
	char g;
};
int main(){
	struct A s;
	printf("%d",sizeof(s));//48 只会把数组中的一个元素当成一个成员
}
------------
struct A{
	char c;
	int a;
	char b;
}
int main(){
	struct A s;
	printf("%d",sizeof(s));//12 由于第一个成员是char类型 char会扩展为和第2个int成员相同的空间
}
-------------
struct A{
	char a;
	short b;
	int c;
	short d;
	char e;
}
int main(){
	struct A a;
	a.a=1;
	a.b=2;
	a.c=3;
	a.d=4;
	a.e=5;
}
//实例化之后的结构体a在内存中结构为
//01 xx 00 02
//00 00 00 03
//00 04 05 xx
//其中xx表示没有被利用的空间 所以sizeof(a)是12
//结构体变量在占内存时总是以2的倍数为开始索引来占据的，再例如：
struct A{
	char a;
	short b;
	int c;
	char f;
	short d;
	char e;
}
int main(){
	struct A a;
	a.a=1;
	a.b=2;
	a.c=3;
	a.d=4;
	a.e=5;
	a.f=6;
}
//结构体变量a在内存中的结构为
//01 xx 00 02
//00 00 00 03
//06 xx xx xx
//00 04 05 xx
//------------------
//所以sizeof(a)是16
struct A{
	char a;
	short b;
	int c;
	short d;
	char e;
	char f;
}
int main(){
	struct A a;
	a.a=1;
	a.b=2;
	a.c=3;
	a.d=4;
	a.e=5;
	a.f=6;
}
-----------------------
//01 xx 00 02
//00 00 00 03
//00 04 05 06
//sizeof(a)是12
//指定结构体成员的位字段
struct D{
	char a:2;//定义一个成员类型为char，但这个成员只是用2个bit
}
int main(){
	struct D d;
	d.a=3;
	printf("%d\n",d.a);//-1
	printf("%d\n",sizeof(d));//1
	return 0;
}
-------------
struct D{
	char a:2;
	char b:2;
}
int main(){
	struct D d;
	printf("%d\n",sizeof(d));//还是1，也就是说我们可以通过字节下的比字节更小的单位bit来控制
	return 0;
}
----------------
struct D{
	char a:2;
	unsigned char b:4;
}
int main(){
	struct D d;
	d.a=3;
	d.b=16;
	printf("%d %d\n",d.a,d.b);//-1 0
	printf("%d\n",sizeof(d));//
	return 0;
}
----------------
在嵌入式的场合通常使用：
struct D{
	char a:1;//只有两种状态，开或者关
}
一个LED灯的话用这样的八个成员就可以了(不要忘了小数点)
============================
struct F{
	int i:2;
	char c:2;
}
int main(){
	printf("%d\n",sizeof(struct F));//8
}
----------------
struct G{
	char a;
	char b;
	char c;
}
int main(){
	struct G g;
	char *p=&g;
	p[0]=3;
	p[1]=4;
	p[2]=0;
	printf("%d %d %d",g.a,g.b,g.c);//3 4 0
}
--------------
struct H{
	char a;
	int b;
}
int main(){
	struct H h={1,2};
	char *p1=&h;
	p1++;
	*p1=4;
	p1++;
	*p1=5;
	printf("%p\n",&h);//01 04 05 xx 02 00 00 00 从结果中可以看出我们已经把第一行char类型浪费的字节利用起来了
	return 0;
}
=================结构体数组
struct student{
	char name[16];
	unsigned char age;
	unsigned char score;
	char classes[100];
};
int main(){
	struct student st[3]={{"aaa",20,50,"c"},{"bbb",21,60,"c++"},{"ccc",22,70,"java"}};
	int i;
	for(i=0;i<5;i++){
		printf("姓名=%s 年龄=%d 成绩=%d 班级=%s\n",st[i].name,st[i].age,st[i].score,st[i].classes);
	}
	return 0;
}
----------------
struct A{
	char array[10];
}
int main(){
	struct A a1={"hello"};//如果结构体的成员是数组，通过结构可以变相的实现数组的赋值，而数组之间是不可以直接赋值的
	struct A a2={0};
	a2=a1;//这样写是合法的
	printf("%s",a2.array);
}
-------------------
void swap(struct student *a,struct student *b){
	struct student tmp=*a;
	*a=*b;
	*b=tmp;
}
int main(){
	int i;
	int j;
	for(i=0;i<5;i++){
		for(j=1;j<5-i;j++){
			if(st[j].age<st[j-1].age){
				swap(&st[j],&st[j-1]);
			}else if(st[j].age==st[j-1].age){
				//如果年龄一样就比较分数
				if(st[j].score<st[j-1].score){
					swap(&st[j],&st[j-1]);
				}
			}
		}
	}
}
---------------
//如果通过班级来排序，即给字符串排序
int main(){
	int i;
	int j;
	for(i=0;i<5;i++){
		for(j=1;j<5-i;j++){
			if(strcmp(st[j].classes,st[j-1].classes)>0){
				swap(&st[j],&st[j-1]);
			}
		}
	}
	return 0;
}
==================结构嵌套
struct A{
	int a;
	char b;
};
struct B{
	struct A a;
	char b;
}
int main(){
	printf("%d\n",sizeof(struct B));//12
	return 0;
}
===============
struct A{
	int a;
	int b;
};
struct B{
	int c;
	struct A a;
	int b;
};
struct C{
	struct B b;//仍然以int对齐
	char d;
};
int main(){
	printf("%d",sizeof(struct C));//20
}
===============
struct A1{
	char a;
}
struct A2{
	struct A1 a;
	char b;
}
struct A3{
	struct A2 a;
	char b;
}
int main(){
	struct A3 a3;
	//a3.a.a.a=100; 栈中的结构体通过点访问
	struct A3 *ap=malloc(sizeof(struct A3));
	ap->a.a.a=20;//堆中的结构体通过->访问
}
===========结构体拷贝
struct A a1,a2;
a1.a=1;
a1.b=2;
a2=a1;//结构体之间内存的拷贝 相当于memcpy(&a2,&a1,sizeof(a1));
===============指向结构体的指针
struct A a;
struct A *p=&a;
p->a=10;//相当于(*p).a=10;
p->b=20;//相当于(*p).b=10;
=================堆内存结构体
int main(){
	struct A *p=malloc(sizeof(struct A)*10);
	memset(p,0,sizeof(struct A)*10);
	struct A *array=p;
	p->a=1;
	p->b=2;
	p++;
	p->a=3;
	p->b=4;
	int i;
	for(i=0;i<10;i++){
		printf("%d %d",array[i].a,array[i].b);
	}
	free(array);//不能free掉p，因为p已经赋给array了，free知道要去释放10个字节的内存，如果要去free p的话，从第2个字节的内存开始free，free到第10个字节的内存时还没有free完，就再去free没有通过malloc分配的内存，这样一定会出问题
	return 0;
}
=============结构体中的数组成员和指针成员
struct student{
	char name[100];
	int age;
}
struct student_a{
	char *name;
	int age;
}
int main(){
	struct student_a st={NULL,0};
	st.age=30;
	st.name=malloc(100);
	strcpy(st.name,"myj");
	printf("%d %s",st.age,st.name);
	free(st.name);
}
=================
struct student{
	char name[100];
	int age;
}
struct student_a{
	char *name;
	int age;
}
int main(){
	struct student_a st={NULL,0};
	st.age=30;
	st.name=malloc(100);
	strcpy(st.name,"myj");
	struct student_a st1=st;
	printf("%d %s",st1.age,st1.name);//30 乱码
	free(st.name);
}
=================
struct man{
	char *name;
	int age;
}
int main(){
	struct man m={"tom",20};
	printf("name=%s age=%d\n",m.name,m.age);//看起来结果正常
}
//但是假如用strcpy改一下name：
int main(){
	struct man m={"tom",20};
	strcpy(m.name,"mike");//程序会挂掉
	printf("name=%s age=%d\n",m.name,m.age);
}
//如果结构体中name的定义改成了char name[100] 就没问题
//name是指针类型时，struct man m={"tom",20}; 执行完了之后m.name就指向了常量"tom"的地址
//strcpy(m.name,"mike");这种操作是去修改一个常量，而常量是不可以修改的，所以会挂掉
//结构体中的成员是指针类型的时候通常通过以下方式赋值
struct man m;
m.name=malloc(sizeof(char)*100);//在堆中给name分配100字节
strcpy(m.name,"mike");
free(m.name);//要记得释放
===============
struct student{
	char name[100];
	int age;
}
int main(){
	//struct student st; 在栈里面
	struct student *p=malloc(sizeof(struct student)); //在堆里面
	free(p);
	return 0;
}
=================
struct man{
	char *name;
	int age;
};
int main(){
	struct man *p=malloc(sizeof(struct man));//结构体变量p在堆中
	p->name=malloc(sizeof(char)*100);//结构体变量p的成员name也在堆中
	strcpy(name,"tom");
	p->age=30;
	printf("name=%s age=%d\n",p->name,p->age);
	free(p->name);//注意释放的顺序一定得是先释放p的成员name，再释放整个结构体
	free(p);
}
===========将结构作为函数参数
struct student{
	char name[100];
	int age;
};
void print_student(struct student s){//一般不把结构类型变量作为函数参数，因为结构类型可能很大，函数调用式，实参和形参在栈内存中同时存在，就会极大浪费栈内存
	printf("name=%s age=%d",s.name,s.age);
}
void set_student(struct student s,const char *name,int age){
	strcpy(s.name,name);
	s.age=age;
}
int main(){
	struct student st={"tom",20};
	set_student(st,"mike",100);
	print_student(st);//打印出来的是tom 就是普通类型的变量
}
//想要改的话只能传递地址：
struct student{
	char name[100];
	int age;
};
void print_student(struct student s){
	printf("name=%s age=%d",s.name,s.age);
}
void set_student(struct student *s,const char *name,int age){
	strcpy(s->name,name);
	s->age=age;
}
int main(){
	struct student st={"tom",20};
	set_student(&st,"mike",100);
	print_student(st);//打印出来的是mike
}
==================联合体/共用体
union A{
	int a;
	int b;
};
int main(){
	union A a;
	a.a=10;
	a.b=20;
	printf("%d",sizeof(union A));//4
	printf("%p %p",&a.a,&a.b);//内存一样
	printf("a=%d",a.a);//20 因为共用一块内存
}
联合体union是一个能在同一个存储空间存储不同类型数据的类型
联合体所占的内存长度等于其最长成员的长度，也有叫做共用体
联合体虽然可以有多个成员，但同一时间只能存放其中一种
在上面的例子中联合体内成员a和b是共用一块地址的
===========
union A{
	unsigned char a;
	char b;
};
int main(){
	union A a;
	a.a=128;
	//a.b=20;
	printf("%d",sizeof(union A));//1 以联合体中长度最大的那个成员为准
	printf("%p %p",&a.a,&a.b);
	printf("a=%d",a.a);//128
	printf("b=%d",a.b);//-128
}
============联合体中的指针成员
union A{
	char a;
	char *b;
};
int main(){
	union A a;
	a.b=malloc(100);//b指向了一个堆的地址
	a.a=10;//但是给a赋值之后b的值成了10，所以下面就free不了了
	free(a.b);
	return 0;
}
==============如果联合体中有指针成员，那么一定要使用完这个指针，并且free指针之后才能使用其他成员
union A{
	char a;
	char *b;
};
int main(){
	union A a;
	a.b=malloc(100);//b指向了一个堆的地址
	free(a.b);
	a.a=10;//但是给a赋值之后b的值成了10，所以下面就free不了了
	return 0;
}
====================枚举类型
enum A{
	red,green,black,yellow //相当于定义了4个常量，都是int类型的 值分别为0 1 2 相当于用#define定义的常量
};
int main(){
	int color=black;//但是这里不可以给black赋值 枚举是整数常量
	printf("%d",red);//0
	printf("%d",green);//1
	printf("%d",black);//2
	printf("%d",yellow);//3

	printf("%d",color);//2
}
===========
enum A{
	red=5,black,yellow,green
};
//现在black变成了6 yellow是7 ...

enum A{
	red=5,black=2,yellow,green
};
//yellow是3
==================typedef
typedef是一种高级数据特性，它能使某一类型创建自己的名字
typedef char BYTE;//定义了新的数据类型，名字叫BYTE，类型是char
#define BYTE1 char//define只是做了一个语法替换，但是typedef就是定义了一种类型，并不单单是替换
int main(){
	BYTE a;
	BYTE1 a1;
	a=10;
	printf("%d",a);
	return 0;
}

====================
#define MAX 10不可以替换成typedef 10 AAA;
===============
struct abc{
	int a;
	char b;
};
typedef struct abc A;
int main(){
	A a;//就不用一直写struct关键字了
}
================上面的typedef定义的类型还有一种简化写法，而这种写法是define做不到的
typedef struct{
	int a;
} A2;
==============
char *mystrcat(char *s1,char *s2){
	strcat(s1,s2);
	return s1;
}
//test函数的第一个参数是函数指针 但是这个函数的定义太复杂 所以我们一般避免这样写
char *test( char *(*p)(char *,char *),char *s1,char *s2 ){
	return p(s1,s2);
}
int main(){
	char s1[100]="hello";
	char s2[100]="world";
	char *s=test(mystrcat,s1,s2);
	printf("%s",s);//helloworld
	return 0;
}
================
char *mystrcat(char *s1,char *s2){
	strcat(s1,s2);
	return s1;
}
typedef char *(*STRCAT)(char *,char *)//STRCAT可以指向两个参数是char*类型，返回值也是char*类型的函数
char *test( STRCAT p, char *s1, char *s2 ){
	return p(s1,s2);
}
int main(){
	STRCAT array[10];//定义了一个每个成员的类型都是STRCAT的数组，该数组长度是10
	//如果用原始的方法定义的话可读性极差：char *(*p[10])(char *s1,char *s2); 而且在这里typedef是无法用#define替换的

	char s1[100]="hello";
	char s2[100]="world";
	char *s=test(mystrcat,s1,s2);
	printf("%s",s);//helloworld
	return 0;
}
===============文件操作
int main(){
	FILE *p=fopen("D:\\temp\\a.txt","w");//用写的方式打开一个文件
	//w的意思是如果文件不存在就建立一个，如果文件存在就覆盖
	fputs("hello world",p);//向文件中写入一个字符串
	fclose(p);//关闭文件
}
=========
int main(void){
	char s[1024]={0};
	FILE *p=fopen("D:\\temp\\a.txt");
	while(1){
		memset(s,0,sizeof(s));
		gets(s);//gets可以接收空格 而scanf("%s",s);不可以
		if(strcmp(s,"exit")==0){
			break;
		}
		int len=strlen(s);
		s[len]='\n';//由于我们并不能将scanf中输入的换行显示在文本当中 所以要在每次输入完成字符串之后 按照每次输入的内容换行
		fputs(s,p);
	}
	fclose(p);
	printf("end\n");
	return 0;
}
================读文件
int main(){
	char s[1024]={0};
	FILE *p=fopen("D:\\temp\\a.txt","r");
	//feof(p);如果已经到了文件结尾，feof函数返回真
	while(!feof(p))//如果没有到文件结尾就一直循环
	{
		memset(s,0,sizeof(s));
		fgets(s,sizeof(s),p);//参数分别是内存地址 这块内存大小 fopen返回的文件指针
		printf("%s",s);
	}
	fclose(p);
	return 0;
}
=========文本文件加密
void code(char *s){
	while(*s){
		(*s)++;
		s++;
	}
}
void decode(char *s){
	while(*s){
		(*s)--;
		s++;
	}
}
int main(){
	char s[1024]={0};
	FILE *p=fopen("D:\\temp\\a.txt","r");
	FILE *p1=fopen("D:\\temp\\b.txt","w");
	while(!feof(p))//如果没有到文件结尾就一直循环
	{
		memset(s,0,sizeof(s));
		fgets(s,sizeof(s),p);
		code(s);
		fputs(s,p1);
	}
	fclose(p);
	fclose(p1);
	return 0;
}
================fopen
r 以只读方式打开文件，该文件必须存在
r+ 以可读写方式打开文件，该文件必须存在
rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在
rw+ 读写打开一个文本文件，允许读和写
w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失，若文件不存在则建立该文件
w+ 打开可读写文件，若文件存在则文件长度清为0，即该文件内容会消失，若文件不存在则建立该文件
a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留(EOF符保留)
a+ 以附加的方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留(EOF符保留)

FILE *p=fopen("D:\\temp\\aaaa.txt","r");//如果文件打开，fopen返回打开的文件的指针，如果失败返回NULL
//FILE *p=fopen("D:\\temp\\aaaa.txt","a"); 用追加的方式打开文件，如果文件不存在，就创建这个文件，如果文件存在，就在文件结尾追加
if(p==NULL){
	printf("open fail\n");
}else{
	printf("open success\n");
}
printf("end\n");
====================
int main(){
	FILE *p=fopen("D:\\temp\\aaaa.txt","w");
	if(p==NULL){
		printf("file open fail\n");
	}else{
		fputs("hello\n",p);
		fputs("world\n",p);
		fclose(p);
	}
	printf("end\n");
	return 0;
}
这个程序执行完成之后以16进制方式打开文件，看到
68 65 6C 6C 6F 0D 0A 77 6F 72 6C 64 0D 0A
分别对应
h  e  l  l  o  \r \n w  o  r  l  d  \r \n
==============
int main(){
	FILE *p=fopen("D:\\temp\\aaaa.txt","wb");//如果这里加了b 则按照二进制的方式来读取文件，反之按照文本文件方式来读文件，在Windows系统中，文本模式下，文件以\r\n代表换行，若以文本模式打开文件，并用fputs等函数写入换行符"\n"时，函数会自动在"\n"前面加上"\r" 即实际写入文件的是"\r\n"，而如果按照二进制方式读文件，只会读取到\n，不会读取到\r
	//在类Unix/Linux系统中文本模式下，文件以"\n"代表换行，所以Linux系统中在文本模式和二进制模式下并无区别，在Unix/Linux下w和wb是一样的
	if(p==NULL){
		printf("file open fail\n");
	}else{
		fputs("hello\n",p);
		fputs("world\n",p);
		fclose(p);
	}
	printf("end\n");
	return 0;
}
这个程序执行完成之后以16进制方式打开文件，看到
68 65 6C 6C 6F 0A 77 6F 72 6C 64 0A
分别对应
h  e  l  l  o  \n w  o  r  l  d  \n
====================getc putc
int main(){
	FILE *p=fopen("D:\\text\\a.txt","r");
	if(p==NULL){
		printf("error\n");
	}else{
		char c=0;
		//while(c!=EOF){
		//	c=getc(p);
		//	printf("%c\n",c);
		//}
		//上面while的简化写法如下
		while((c=getc(p)) != EOF){
			printf("%c",c);
		}
		fclose(p);
	}
	printf("Hello world!\n");
	return 0;
}

int main(){//写一个字符
	FILE *p=fopen("D:\\text\\a.txt","w");
	if(p==NULL){
		printf("error\n");
	}else{
		char c=0;
		putc('a',p);
		fclose(p);
	}
	printf("Hello world!\n");
	return 0;
}
================EOF和feof
通过fgets读文件的时候通常用feof(p)判断是否到了结尾
通过getc读文件的时候通常用(c=getc(p)) != EOF判断是否到了结尾
==================
文本文件排序
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void swap(int *a,int *b){
	int tmp=*a;
	*a=*b;
	*b=tmp;
}
void pupple(int *p,int n){
	int i;
	int j;
	for(i=0;i<n;i++){
		for(j=1;j<n-i;j++){
			if(p[j-1]>p[j]){
				swap(&p[j-1],&p[j]);
			}
		}
	}
}
int main(void){
	int index;
	int array[10]={0};
	char buf[100];
	FILE *p=fopen("D:\\tmp\\a.txt",r);
	if(p==NULL){
		printf("error\n");
	}else{
		while(!feof(p)){
			memset(buf,0,sizeof(buf));//每次读取文件一行之前都把这个buffer清空
			fgets(buf,sizeof(buf),p);//从文件中读一行
			index++;
			array[index]=atoi(buf);
			fclose(p);
		}
	}
	pupple(array,index);
	p=fopen("D:\\tmp\\a.txt","w");//用写的方式打开b.txt
	int i;
	for(i=0;i<index;i++){
		memset(buf,0,sizeof(buf));//操作buf之前先将它清空
		sprintf(buf,"%d\n",array[i]);//将数组的成员转化为字符串
		fputs(buf,p);
	}
	fclose();
	return 0;
}
//===========动态数组解决上面的问题
int main(){
	int index=0;
	char buf[100];
	FILE *p=fopen("D:\\tmp\\a.txt","r");
	while(!feof(p)){
		memset(buf,0,sizeof(buf));
		fgets(buf,sizeof(buf),p);
		index++;
	}
	fclose(p);
	int *array=calloc(sizeof(int),index);
	p=fopen("D:\\tmp\\a.txt","r");
	index=0;
	while(!feof(p)){
		memset(buf,0,sizeof(buf));
		fgets(buf,sizeof(buf),p);
		array[index]=atoi(buf);
		index++;
	}
	fclose(p);
	pupple(array,index);
	p=fopen("D:\\tmp\\b.txt","w");
	int i;
	for(i=0;i<index;i++){
		memset(buf,0,sizeof(buf));
		sprintf(buf,"%d\n",array[i]);
		fputs(buf,p);
	}
	fclose();
	return 0;
}
================解析文件中的加减乘除
#include<stdio.h>
#include<string.h>
int calc_str(const char *s){
	char buf1[100]={0};
	char oper;
	char buf2[100]={0};
	int len=strlen(s);
	int i;
	for(i=0;i<len;i++){
		if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/'){
			strncpy(buf1,s,i);
			oper1=s[i];
			break;
		}
	}
	int start=i+1;
	for(;i<len;i++){
		if(s[i]=='='){
			strncpy(buf2,&s[start],i-start);
		}
	}
	//printf("buf1=%s,oper1=%c,buf2=%s\n",buf1,oper1,buf2);
	switch(oper1){
		case '+':
			return atoi(buf1)+atoi(buf2);
		case '-':
			return atoi(buf1)-atoi(buf2);
		case '*':
			return atoi(buf1)*atoi(buf2);
		case '/':
			int a=atoi(buf2);
			if(a){
				return atoi(buf1)/atoi(buf2);
			}else{
				return 0;
			}
	}
}
void curReturn(char *s){
	int len=strlen(s);
	if(s[len-1]=='\n'){
		s[len-1]=0;
	}
}
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","r");
	FILE *p1=fopen("D:\\tmp\\b.txt","w");
	char buf[1024];
	char buf1[1024];
	while(!feof(p)){
		memset(buf,0,sizeof(buf));
		fgets(buf,sizeof(buf),p);//从文件中读取一行记录，字符串最后是以'\n'结尾的
		cutReturn(buf);
		int value=calc_str(buf);
		memset(buf1,0,sizeof(buf1));
		sprintf(buf1,"%s%d\n",buf,value);
		printf("buf1=%s",buf1);
		fputs(buf1,p1);
	}
	fclose(p);
	fclose(p1);
	return 0;
}
==================fscanf
int main(){
	FILE *p=fopen("D:\\temp\\a.txt","r");
	while(!feof(p)){
		char buf[100]={0};
		//fgets(buf,sizeof(buf),p);
		fscanf(p,"%s",buf);//fscanf与scanf用法基本一致，fscanf是从一个文件读取输入，scanf是从键盘读取输入
		printf("%s",buf);
	}
	fclose(p);
	return 0;
}
int main(){
	FILE *p=fopen("D:\\temp\\a.txt","r");
	while(!feof(p)){
		char buf[100]={0};
		int a=0;
		int b=0;
		fscanf(p,"%d + %d =",&a,&b);//文件中内容必须是固定格式为xx + xx =的形式
		printf("%d %d",a,b);
	}
}
=================printf
int main(){
	FILE *p=fopen("D:\\temp\\a.txt","r");
	char buf[100]="hello world";
	fprintf(p,"%s",buf);//和printf类似，printf输出到屏幕上，fpritnf输出到文件里面
	int a=6;
	int b=7;
	fclose(p);
	return 0;
}
=================fread
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","rb");//rb代表用读二进制的方式打开一个文件
	char buf[1024]={0};
	fread(buf,sizeof(char),1,p)//第一个参数是缓冲区(存放读取的内容)，第二个参数是读取的基本单元的大小
	//第三个参数是一次读取几个基本单元，第四个参数是打开的文件指针
	printf("buf=%s\n",buf);
	fclose(p);
	return 0;
}
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	while(!feof(p)){
		char buf[10]={0};
		fread(buf,sizeof(char),sizeof(buf),p)
		printf("buf=%s\n",buf);//由于文件中每行都是以\r\n结尾的，一个字节一个字节往出读的话就会把\r\n也读到屏幕上，就会显示出非法的字符
	}
	fclose(p);
	return 0;
}
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	while(!feof(p)){
		char buf[10]={0};
		fread(buf,sizeof(char),sizeof(buf)-1,p)//第三个参数设置为buf的长度减1是为了保证buf是一个合法的字符串(有结尾符)，在下面的printf中就可以直接将读取到的字符串输出了，而且输出的过程中会根据buf最后一个0自动换行
		printf("%s",buf);
	}
	fclose(p);
	return 0;
}
=================
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt");;
	char buf[1024]={0};
	//fread返回值代表读取了多少记录数
	size_t rec=fread(buf,sizeof(char),sizeof(buf),p);//size_t是无符号整型
	printf("%u",res);//如果文件中有3个字符，返回3，有4个字符，返回4，返回的是sizeof(int)的个数
	fclose(p);
}
=============
int main(){
	//假设a.txt中的内容是
	//ab
	//cd
	//以rb 即二进制方式读文件a.txt时，输出的是61 62 a d 63 64，其中a是\n，d是\r
	//以r  即文本文件方式读文件a.txt时，输出的是61 62 a 63 64
	//Windows下如果读取二进制文件必须要加上b，不能只写r
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	while(!feof(p)){
		char buf[1024]={0};
		int res=fread(buf,sizeof(char),sizeof(buf),p);
		int i;
		for(i=0;i<res;i++){
			printf("%x ",buf[i]);
		}
	}
	fclose(p);
	return 0;
}
============fwrite
int main(){
	FILE *p=fopen("D:\\tmp\\a.dat","wb");
	char buf[1024]={0};
	buf[0]='a';
	buf[1]='b';
	fwrite(buf,sizeof(char),2,p);
	fclose(p);
}
============二进制文件拷贝
#include<stdlib.h>
#include<string.h>
int main(){
	FILE *p=fopen("D:\\tmp\\a.wmv","rb");
	FILE *p1=fopen("D:\\tmp\\b.wmv","wb");
	char buf[1024 * 4];//每次读4K
	while(!feof(p)){
		memset(buf,0,sizeof(buf));
		size_t res = fread(buf,sizeof(char),sizeof(buf),p);//返回从源文件中读取的字节数
		fwrite(buf,sizeof(char),res,p1);//从源文件中读取多少字节，就往目标文件写多少字节
		//这里一定不能写成fwrite(buf,sizeof(char),sizeof(buf),p1);因为sizeof(buf)是大于等于res的，很有可能拷贝进去多余的字符，如果是拷贝二进制文件，很有可能导致二进制文件打不开
	}
	fclose(p);
	fclose(p1);
	return 0;
}
=================二进制文件的加密
#include<stdlib.h>
#include<string.h>
void code(char *p,size_t n){
	size_t i;
	for(i=0;i<n;i++){
		p[i]+=3;
	}
}
void decode(char *p,size_t n){
	size_t i;
	for(i=0;i<n;i++){
		p[i]-=3;
	}
}
int main(){
	FILE *p=fopen("D:\\tmp\\a.wmv","rb");
	FILE *p1=fopen("D:\\tmp\\b.wmv","wb");
	char buf[1024 * 4];//每次读4K
	while(!feof(p)){
		memset(buf,0,sizeof(buf));
		size_t res = fread(buf,sizeof(char),sizeof(buf),p);
		code(buf,res);
		fwrite(buf,sizeof(char),res,p1);
	}
	fclose(p);
	fclose(p1);
	return 0;
}
=============stat函数 用stat读取文件比上面的方式效率要高很多
#include<stdlib.h>
#include<string.h>
#include<sys/stat.h>
int main(){
	clock_t c1=clock();//时间戳
	struct stat st={0};
	stat("D:\\tmp\\a.txt",&st);//调用完stat函数之后，文件相关的信息就保存在stat中了
	//printf("%u\n",st.st_size);得到文件大小
	char *arr=malloc(st.st_size);//根据文件大小在堆中动态分配内存
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	fread(arr,sizeof(char),st.st_size,p);//一下把整个文件放入内存
	fclose(p);
	p=fopen("D:\\tmp\\b.wmv","wb");
	fwrite(array,sizeof(char),st.st_size,p);//将堆中的信息一下都写入文件
	fclose(p);
	clock_t c2=clock();//时间戳
	printf("%u",c2-c1);
	return 0;
}
===============结构体与二进制文件
struct student{
	char a;
	int age;
};
int main(){
	struct student st={'a',25};
	FILE *p=fopen("D:\\tmp\\a.dat","wb");//a.dat里面内容是61 00 00 00 1E 00 00 00
	fwrite(&st,sizeof(st),1,p);
	fclose(p);
}
===============生成一个超大文件
#include<time.h>
int main(){
	srand(time(NULL));
	int i;
	FILE *p=fopen("D:\\tmp\\a.txt","w");
	for(i=0;i<1000000000;i++){
		fprintf(p,"%d\n",rand() % 256);
	}
	fclose(p);
	printf("end");
	return 0;
}
//生成的a.txt会很大，大到打开a.txt时都加载不出来，几十兆就打不开了
//如果我们需要对a.txt中的数字进行排序，如果不操作堆内存的话要怎么做呢？
//先考虑小文件的情况
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","r");
	int array[256]={0};
	while(!feof(p)){
		char buf[100]={0};
		fgets(buf,sizeof(buf),p);//得到一行
		if(buf[0]!=0){//有时候我们会发现b.txt里面第一行是0，但是a.txt文件里面没有哪一行有0，那么证明a.txt文件里面的最后一行是空行
			int value=atoi(buf);//将得到的行转化为整数
			array[value]++;
		}
	}
	fclose(p);
	p=fopen("D:\\temp\\b.txt","w");
	int i;
	int j;
	for(i=0;i<513;i++){
		for(j=0;j<array[i];j++){
			fprintf(p,"%d\n",i);
		}
	}
	fclose(p);
	printf("end");
	return 0;
}
=================fseek函数
struct student{
	char name[10];
	int age;
};
int main01(){
	struct student st[10]={0};
	int i;
	for(i=0;i<10;i++){
		scanf("%s",st[i].name);
		scanf("%d",&st[i].age);
	}
	FILE *p=fopen("D:\\txt\\a.dat","wb");
	fwrite(st,sizeof(struct student),10,p);
	return 0;
}
int main(){
	struct student st={0};
	FILE *p=fopen("D:\\txt\\a.dat","rb");

	//读取第一个结构体
	memset(&st,0,sizeof(struct student));
	fread(&st,sizeof(struct student),1,p);
	printf("name=%s,age=%d\n",st.name,st.age);

	//读取第二个结构体
	memset(&st,0,sizeof(struct student));
	fread(&st,sizeof(struct student),1,p);
	printf("name=%s,age=%d\n",st.name,st.age);

	//读取第三个结构体
	memset(&st,0,sizeof(struct student));
	fread(&st,sizeof(struct student),1,p);
	printf("name=%s,age=%d\n",st.name,st.age);
	//目前文件指针p在第4个结构，如果在这时想回去的话，可以通过fseek实现
	//或者希望从中间开始读文件，或者倒着往回读，都可以用fseek实现
	fseek(p,sizeof(struct student),SEEK_SET);//SEEK_SET是一个宏，代表文件的开始位置，第二个参数意思是在第三个参数的基础上向后偏移sizeof(struct student)个字节读取
	//第二个参数可以是负值
	//除了SEEK_SET之外，还有SEEK_CUR(当前位置)，SEEK_END(文件结尾位置)
}
-----------
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	fseek(p,-5,SEEK_END);//从后往前移动了5个字节
	char buf[100]={0};
	fgets(buf,sizeof(buf),p);
	printf("%s",buf);//输出a.txt中的最后5个字节的内容
	fclose(p);
	return 0;
}
=================ftell
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","rb");
	fseek(p,-5,SEEK_END);
	char buf[100]={0};
	fgets(buf,sizeof(buf),p);
	printf("%s",buf);
	printf("%d",ftell(p));//得到目前在第几个字节上
	fclose(p);
	return 0;
}
============fflush
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt","w");
	while(1){
		char buf[100]={0};
		scanf("%s,buf");
		if(strcmp(buf,"exit") == 0){
			break;
		}
		fprintf(p,"%s\n",buf);//事实上fprintf并没有真正的将输入的内容写入文件中，由于scanf可以中断程序执行过程，因此，我们可以每次输入内容再回车之后观察一下a.txt的大小是否变化，但通过观察，它的大小并没有变化，而是在按下exit键退出的时候从0字节一下变成了输入内容的长度，也就是说在fclose这一步才将内容真正写入文件，Java中的IO也是如此
		fflush(p);//将缓冲区内容立刻写入文件，不会等fclose和缓冲区满
		//优势是不会因为停电或者电脑死机等故障导致缓冲区的内容丢失
		//不好的是硬盘读写次数增加，导致程序效率低下，同时硬盘寿命变短
		//修改配置文件的时候，有时会使用，或者做一些不经常修改但是很重要的数据才用fflush
	}
	fclose(p);
	return 0;
}
//整体读写流程：用户程序->C语言库函数->操作系统->硬盘 磁盘的寿命是读写磁盘的次数
//每当程序通过C语言库函数往文件里面写数据，C语言库函数并不是实时的将数据直接写入磁盘，而是放到内存里面，当内存满了或者明确的调用了fclose，才将数据一次性写入磁盘
//结论：C语言所有的文件操作函数都是缓冲区函数，缓冲区满了或者调用fclose才会写入
================remove和rename不是读写文件的，而是操作文件的函数
int main(){
	remove("D:\\tmp\\a.txt");//删除文件
	rename("D:\\tmp\\c.txt","D:\\tmp\\a.txt");//改名
}
============将二进制文件按照年龄排序
//int main(){
//	struct student st[10]={0};
//	int i;
//	for(i=0;i<10;i++){
//		scanf("%s",st[i].name);
//		scanf("%d",&st[i].age);
//	}
//	FILE *p=fopen("D:\\txt\\a.dat","wb");//a.dat里面存储有若干学生结构体，要按照年龄排序
//	fwrite(st,sizeof(struct student),10,p);
//	return 0;
//}
void swap(struct student *a,struct student *b){}{
	struct student tmp=*a;
	*a=*b;
	*b=tmp;
}
void bubble(struct student *p,int n){
	int i;
	int j;
	for(i=0;i<n;i++){
		for(j=1;j<1;j<n-i;j++){
			if(p[j-1].age<p[j].age){
				swap(&p[j-1],&p[j]);
			}
		}
	}
}
int main(){
	FILE *p=fopen("D:\\txt\\a.dat","rb");
	struct student st[5]={0};
	int i;
	//用循环读取
	//for(i=0;i<5;i++){
	//	fread(&st[i],sizeof(struct student),1,p);
	//}
	//直接读取
	fread(st,sizeof(struct student),5,p);
	fclose(p);
	bubble(st,5);
	//for(i=0;i<5;i++){
	//	printf("%s %d",st.name,st.age);
	//}
	p=fopen("D:\\tmp\\b.dat","wb");
	//用循环读取
	//for(i=0;i<5;i++){
	//	fwrite(st[i],sizeof(struct student),1,p);
	//}
	fwrite(st,sizeof(struct student),5,p);
	fclose(p);
	return 0;
}
=========文件操作复习
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt");//假设a.txt里面的内容是hello
	while(!feof){
		char c=getc(p);
		printf("%x",c);
	}
	fclose(p);
	return 0;
}
//最后输出了一个ffffff，这个ffffff不是文件的一部分，是文件的结尾，换算成十进制是-1
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt");
	while(c!=-1){//-1就是EOF
		char c=getc(p);
		printf("%x",c);
	}
	fclose(p);
	return 0;
}
//简化写法
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt");
	char c=0;
	while((c=getc(p))!=EOF){
		printf("%x",c);
	}
	fclose(p);
	return 0;
}
//和getc相对应的，putc方法是一个字符一个字符往文件里面写
fprintf fscanf fgets fputs都是操作一行
-------------------将文件中所有的内容读到一个字符数组中
int main(){
	FILE *p=fopen("D:\\tmp\\a.txt");
	char content[1024]={0};//假设a.txt内容小雨1024
	while(!feof(p)){
		char buf[100]={0};
		fgets(buf,sizeof(buf),p);
		strcat(content,buf);
	}
	printf("%s",content);
	fclose(p);
	return 0;
}
--------------读取二进制文件
int main(){
	int array[10]={0,1,2,3,4,5,6,7,8,9};
	FILE *p=fopen("D:\\tmp\\a.abc");//记事本打开是乱码
	int i;
	for(i=0;i<10;i++){
		fwrite(&array[i],sizeof(int),1,p);
	}
	fclose(p);
	return 0;
}
---------------两种写法区别
//方式一
while(!feof(p)){
	fread(&buf,1,sizeof(buf),p);
}
//方式二
while(fread(&buf,1,sizeof(buf),p) != 0)
//第一种方式可能会多读出一行，为什么？？？
-----------
fseek的返回值0代表成功，-1代表失败，但是如果往后移动文件指针超过文件大小，fseek的返回值还是0，但是往前移动超过文件开始位置-1，使用时需要注意
如果没有明确调用fclose结束一个文件，那么在进程退出后，操作系统会自动调用fclose，但是不能依赖操作系统的这个功能
操作系统能够打开的文件个数是有限的
尽量不要在一个程序中操作很多文件，如果的确需要操作很多文件，也要先把上一个关闭了在去打开下一个
===================算法
冒泡排序
void swap(int *a,int *b){
	int tmp=*a;
	*a=*b;
	*b=tmp;
}
void bubble(int *array,int n){
	int i;
	int j;
	for(i=0;i<n;i++){
		for(j=1;j<n-i;j++){
			if(array[j-1]>array[j]){
				swap(&array[j-1],&array[j]);
			}
		}
	}
}
选择排序 在一个集合里面找最小的数，将最小的书放到集合的最前面
第二个参数是数组开始下标，第三个参数是数组的终止下标
int minkey(int *array,int low,int high){
	int min=low;
	//在没有查找最小元素之前，第一个元素是最小的
	int key=array[low];
	int i;
	for(i=low + 1;i<high;i++){
		if(key>array[i]){
			key=array[i];
			min=i;
		}
	}
	return min;
}
void selectSort(int *array,int n){
	int i;
	for(i=0;i<n;i++){
		int j=minkey(array,i,n);
		if(i!=j){
			swap(&array[i],&array[j]);
		}		
	}
}
=============查找
最简单的查找方法是顺序查找
二分查找(必须是排序之后)
int bin(int *array,int low,int high,int key){
	while(low<=high){
		int mid=(low+high)/2;
		if(key==array[mid]){
			return mid;
		}else if(key>array[mid]){
			low=mid+1;
		}else{
			high=mid-1;
		}
	}
	return -1;
}
==========递归实现二分查找
int bin_rec(int *array,int low,int high,int key){
	if(low<=high){
		int mid=(low+high)/2;
		if(key==array[mid]){
			return mid;
		}else if(key>=array[mid]){
			return bin_rec(array,mid+1,high,key);
		}else{
			return bin_rec(array,low,mid-1,key);
		}
	}else{
		return -1;
	}
}
===========单向链表
对于数组，逻辑上相邻的两个元素的物理位置也是相邻的，这种结构可以随机存储任意位置的元素，但是缺点是从数组中间删除或者插入元素时，需要大量移动元素，效率很低，链表与之相反
#include<stdlib.h>
struct list{
	int data;//数据域
	struct list *next;//指针域
};
//ADT
struct list *create_list(){
	return calloc(sizeof(struct list),1);
}
void traverse(struct list *ls){
	struct list *p=ls;
	while(p){
		printf("%d\n",p->data);
		p=p->next;
	}
}
//在链表ls的第n个元素后面插入节点，数据域为data
struct list *insert_list(struct list *ls,int n,int data){
	struct list *p=ls;
	while(p && n--){
		p=p->next;
	}
	if(p==NULL){
		return NULL;//n的位置大于链表节点数
	}
	struct list *node=create_list();
	node->data=data;
	node->next=p->next;
	p->next=node;
	return node;
}
int delete_list(struct list *ls,int n){
	struct list *p=ls;
	while(p&&n--){
		p=p->next;
	}
	if(p==NULL){
		return -1;
	}
	struct list *tmp=p->next;
	p->next=p->next->next;
	free(tmp);
	return 0;
}
int count_list(struct list *ls){
	struct list *p=ls;
	int count=0;
	while(p){
		count++;
		p=p->next;
	}
	return count；
}
void clear_list(struct list *ls){
	struct list *p=ls->next;//保留首节点
	while(p){
		struct list *tmp=p->next;
		free(p);
		p=tmp;
	}
	ls->next=NULL;//只有首节点，那么首节点的next也应该是NULL
}
int empty_list(struct list *ls){
	if(ls->next){
		return 0;
	}else{
		return -1;
	}
}
//返回指定位置的节点
struct list *locale_list(struct list *ls,int n){
	struct list *p=ls;
	while(p && n--){
		p=p->next;
	}
	if(p==NULL){
		return NULL;
	}
	return p;
}
//返回数据域为data的节点
struct list *elem_locale(struct list *ls,int data){
	struct list *p=ls;
	while(p){
		if(p->data==data){
			return p;
		}
		p=p->next;
	}
	return NULL;//没有找到数据域为data的节点
}
int elem_pos(struct list *ls,int data){
	int index=0;
	struct list *p=ls;
	while(p){
		index++;
		if(p->data==data){
			return index;
		}
		p=p->next;
	}
	return -1;//没有找到数据域为data的节点
}
struct list *last_list(struct list *ls){
	struct list *p=ls
	while(p->next){//p->next为NULL时跳出循环
		p=p->next;
	}
	return p;
}
void merge_list(struct list *ls1,struct list *ls2){
	//只合并链表的节点，不合并链表头，即丢弃ls2的头节点
	last_list()->next=ls2->next;
	free(ls2);
}
//链表逆置 首节点不动
void reverse(struct list *ls){
	//只有一个节点
	if(ls->next==NULL){
		return;
	}
	//只有两个节点
	if(ls->next->next==NULL){
		return;
	}
	//上一个指针
	struct list *pre=ls
	//当前节点指针
	struct list *cur=ls->next;
	//下一个节点指针
	struct list *next=NULL;
	struct list *last=ls->next;//逆置后ls->next就成额最后一个节点了
	while(cur){
		next=cur->next;
		cur->next=pre;
		pre=cur;
		cur=next;
	}
	ls->next=ls;
	last->next=NULL;
}
int main(){
	struct list *first=create_list();
	struct list *second=create_list();
	struct list *third=create_list();

	//链表必须从首节点开始指向第二个节点，再将第二个节点指向第三个节点，以此类推
	first->next = second;
	second->next = third;
	third->next = NULL;//链表最后一个节点，next一定要是空

	first->data=1;
	second->data=2;
	third-data=3;

	traverse(first);

	return 0;
}
//=================C++基本概念
#include<iostream>//C++的头文件或者是没有扩展名的 或者是.hpp
using namespace std;
int main(){
	cout<<"Hello world"<<endl;
	return 0;
}




