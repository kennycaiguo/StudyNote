React

优势：
1、组件化
2、虚拟DOM 性能高
3、跨平台 移动端

缺点：
1、学习曲线特别陡
2、设计思想有点特别

React全家桶（技术栈）
1、React主体
2、webpack 类似grunt gulp
3、Flex 布局用的
4、React-Route：路由
5、Redux：View层 拆分复杂页面 对于极度复杂的情况才会用到
6、Mocha：测试
7、Istanbul：覆盖率

JSX：
1、增强型JS语法——HTML代码可以直接放在js里面
2、需要编译，通过babel可以编译JSX

babel注意事项：
1、babel里面每个xml节点有且只能有一个顶级元素
2、模板字符串 var oDiv = <div>{aaa}</div>; //将aaa变量输出到div中
3、babel本身是转换ECMAScript6代码的，后期才扩展了JSX

最强：
1、组件化
2、状态


组件：
1、定义组件
class Comp extends React.Component{
	//必须要有render方法
	render(){
		return <span></span>
	}
}
2、使用组件
ReactDOM.render(
	<Comp />
	oDiv
);


//错误写法：<input type="text" onChange="{this.fnChange.bind(this)}"/>
//正确写法：<input type="text" onChange={this.fnChange.bind(this)}/>


组件的Constructor中必须调用super


//style比较特殊，不可以写单花括号，因为style里面的值是成对出现的，而且style的值也不可以是字符串，否则报错
//错误写法：<div className="box" style="{display:this.state.display}"></div>
//错误写法：<div className="box" style="{{display:this.state.display}}"></div>
//正确写法：<div className="box" style={{display:this.state.display}}></div>


组件生存周期:
componentWillMount: 即将挂载 创建之前
componentDidMount: 创建之后

componentWillUpdate: 即将更新 更新之前
componentDidUpdate: 更新之后

componentWillUnmount: 即将卸载
没有componentDidUnmount 组件已经被销毁

componentWillReceiveProps: 组件参数更新时


=============================================================
妙味React
虚拟DOM：通过DOM diff算法，只会更新有差异化的部分，不用渲染整个页面，DOM diff算法在内存中进行

组件化：组件和组件之间耦合度要尽量低，不要有太多依赖

单向数据流：数据是从顶层组件传递到子组件中、数据可控

JSX：js中操作DOM比较传统的方式是创建节点，然后做拼接，拼接字符串时用加号，总之很复杂，因此JSX就提供了html和js混写的方式

<div id="demo"></div>
<script type="text/babel">
	// 组件名FirstComponent首字母必须大写
	var FirstComponent = React.createClass({
		// 当引入mixins实现双向绑定插件时添加该项
		mixins: [React.addons.LinkedStateMixin],
		getInitialState: function(){
			return {
				mes: this.props.value
			};
		},
		render: function(){
			return (
				// 注意，一个组件只能有一个顶层标签，所以必须在最外层用div包一下
				<div>
					<h1>{this.props.title}</h1>,
					// 想要在类型为text的input中使用value，要配合onChange来使用，onChange中C必须大写
					// 注意value的值没有引号
					// 如果不想用onChange，可以将value改成defaultValue即可					
					// <input type="text" defaultValue={this.props.txt} />
					// 这样写是不对的，因为props中的值是不可以改变的，想要改变的话应该用state
					// <input type="text" value={this.props.txt} onChange={this.changeHandle} />
					// 使用state时，内部会通过dom diff算法查找不一样的地方去渲染
					// <input type="text" value={this.state.mes} onChange={this.changeHandle} />
					<input type="text" valueLink={this.linkState('mes')} />
					<input type="button" value={this.props.sendName} />
					<p>{this.state.mes}</p>
					<ul>
						{
							// 这里的map最终会返回一个数组，因此这里实际上会变成
							// [<li>1</li>,<li>2</li>,<li>3</li>]
							this.props.listArr.map(function(item,index){
								// 每个li需要加一个key，每一项的key值不能一样
								return <li key={index}>{item}</li>;
							})
						}						
					</ul>
					// 可以单独将上面的ul提出来成为一个独立的组件
					// <ListComponent listArr={this.props.listArr} />
				</div>
			);
		},
		changeHandle: function(ev){
			console.log(ev.target.value);
			this.setState({
				mes: ev.target.value
			});
		}
	});
	
	var ListComponent = React.createClass({
		render: function(){
			return (
				<ul>
					{
						// 这里的map最终会返回一个数组，因此这里实际上会变成
						// [<li>1</li>,<li>2</li>,<li>3</li>]
						this.props.listArr.map(function(item,index){
							// 每个li需要加一个key，每一项的key值不能一样
							return <li key={index}>{item}</li>;
							
							// 这里的内容很复杂时也可以抽成一个组件，注意必须要有key值
							// return <ItemComponent key={index} item={item} />
						})
					}						
				</ul>
			);
		}
	});
	
	// var title = "标题";
	// var send = "提交";
	var obj = {
		title: "标题",
		send: "提交",
		txt: "请输入",
		listArr: [1,2,3,4,5]
	};
	
	ReactDOM.render(
		// 用了全局变量obj
		// ECMA6中可以这样写：<FirstComponent {...obj} />,
		<FirstComponent title={obj.title} sendName={obj.send} />,
		document.getElementById("demo"),
		function(){
			console.log("渲染完成");
		}
	);
</script>

props：组件初始要渲染的数据，不可改变
state：组件状态发生改变，调用render重新渲染


<div id="demo"></div>
<script type="text/babel">
	// 组件名FirstComponent首字母必须大写
	var FirstComponent = React.createClass({
		// 当引入mixins实现双向绑定插件时添加该项
		mixins: [React.addons.LinkedStateMixin],
		getInitialState: function(){
			return {
				mes: this.props.value,
				listArr:this.props.listArr
			};
		},
		render: function(){
			return (
				// 注意，一个组件只能有一个顶层标签，所以必须在最外层用div包一下
				<div>
					<h1>{this.props.title}</h1>,
					// 想要在类型为text的input中使用value，要配合onChange来使用，onChange中C必须大写
					// 注意value的值没有引号
					// 如果不想用onChange，可以将value改成defaultValue即可					
					// <input type="text" defaultValue={this.props.txt} />
					// 这样写是不对的，因为props中的值是不可以改变的，想要改变的话应该用state
					// <input type="text" value={this.props.txt} onChange={this.changeHandle} />
					// 使用state时，内部会通过dom diff算法查找不一样的地方去渲染
					// ref属性相当于一个唯一标识
					// <input type="text" ref="text_input" value={this.state.mes} onChange={this.changeHandle} />
					<input type="text" valueLink={this.linkState('mes')} />
					<input type="button" onClick={this.addItemHandle} value={this.props.sendName} />
					<p>{this.state.mes}</p>
					// 可以单独将上面的ul提出来成为一个独立的组件
					<ListComponent listArr={this.state.listArr} />
				</div>
			);
		},
		changeHandle: function(ev){
			console.log(ev.target.value);
			this.setState({
				mes: ev.target.value
			});
		},
		addItemHandle: function(){
			var value = this.refs.text_input.value;
			var newArr = this.state.listArr.push(value);
			this.setState({listArr:newArr});
		}
	});
	
	var ListComponent = React.createClass({
		render: function(){
			return (
				<ul>
					{
						// 这里的map最终会返回一个数组，因此这里实际上会变成
						// [<li>1</li>,<li>2</li>,<li>3</li>]
						this.props.listArr.map(function(item,index){
							// 每个li需要加一个key，每一项的key值不能一样
							return <li key={index}>{item}</li>;
							
							// 这里的内容很复杂时也可以抽成一个组件，注意必须要有key值
							// return <ItemComponent key={index} item={item} />
						})
					}						
				</ul>
			);
		}
	});
	
	// var title = "标题";
	// var send = "提交";
	var obj = {
		title: "标题",
		send: "提交",
		txt: "请输入",
		listArr: [1,2,3,4,5]
	};
	
	ReactDOM.render(
		// 用了全局变量obj
		// ECMA6中可以这样写：<FirstComponent {...obj} />,
		<FirstComponent title={obj.title} sendName={obj.send} />,
		document.getElementById("demo"),
		function(){
			console.log("渲染完成");
		}
	);
</script>

==============================================================
npm init是创建package.json的向导

npm install --save Lodash //只写--save会添加到dependences里面，dependences是生产依赖

npm install --save-dev gulp //--save-dev会添加到devDependences里面，devDependencies是开发依赖

npm install --save //卸载的同时会删除在package.json中的依赖

babel 搞清楚四个概念 babel-core plugins presets .babelrc
babel-core是babel的核心，但也没中如果只引入了babel-core，那什么也做不了，但是它为编译其他ES6语法提供了基础
如果将babel和操作系统作类比的话，babel-core相当于一个空白的操作系统
plugins 插件 例如es2015-arrow-function用来编译箭头函数 es2015-spread用来编译spread语法，如果一个一个插件装太麻烦，所以出现了presets预设的概念，相当于很多插件的集合

.babelrc 一个配置文件，需要在该文件中指明需要用到什么presets或plugins，此外还有ignore选项

babel还可以把jsx的语法编译成js的语法，用到的插件如下：
preset-flow
syntax-jsx
transform-react-jsx
transform-react-display-name

npm i -D webpack // 是npm install --save-dev webpack的缩写

webpack.config.js
const path = require("path");
module.exports = {
	// 配置入口，即将src目录下的app.js压缩打包，webpack会分析出app.js里面import了哪些js一起压缩进来
	entry: "./src/app.js", //该路径相对于webpack.config.js本身
	// 程序打包好之后的出口
	output: {
		filename: "main.js",
		// 目的路径必须是绝对路径
		path: path.resolve(__dirname, "dist/assets"),
		// 
		publicPath: "/assets/"
	}
};

完成上述webpack.config.js配置文件之后，需要再在package.json中增加
scripts: {
	"test": "echo \"Error: no test specified\" && exit 1",
	"dev": "webpack", //执行npm run dev就相当于执行webpack命令，即根据webpack.config.js打包文件
	//"start": "node server" //执行npm run start就相当于执行node server命令
}
再在该文件夹下执行npm run dev，就可以将所有的文件压缩打包，将程序跑起来

再新建一个index.html页面，在该html里面引入刚刚打包好的main.js
<script src="../dist/main.js"></script>
这个工作我们之后会自动化，而不是手动引入

正式开始react之前，需要先配置package.json和webpack=============================================
webpack.config.js
const path = require("path");
module.exports = {
	entry: [
		"./src/app.js"
	],
	output: {
		filename: "main.js",
		path: path.resolve(__dirname, "dist/assets"),
		// 打包到dist文件夹里面的index.html文件里面自动加上的script的src中会加上publicPath中设置的/assets/前缀
		publicPath: "/assets/"
	},
	module: {
		rules: [
			{
				// 遇到结尾为js的文件时会用babel-loader插件处理该文件，会在.babelrc中会寻找preset预设的react插件
				test: /\.js$/,
				use: ["babel-loader"],
				include: [
					path.resolve(__dirname, "./src")
				]
			},
			{
				test: /\.css$/,
				use: ["style-loader", "css-loader"]
			}
		]
	},
	plugins: [
		// 开启热替换
		new webpack.HotModuleReplacementPlugin(),
		new HtmlWebpackPlugin({
			// 将template中设置的页面打包到dist目录下，而且还会在该页面中插入script标签，并将js动态引入
			// 此处的路径还可以设置为../in.html等自定义的形式
			filename: "index.html",
			// 源路径
			template: "./src/index.html"
		})
	],
	// 以后再说
	devtool: "cheap-module-eval-source-map"
};

还需要编写server.js，来开启一台开发服务器
const webpack = require("webpack");
const path = require("path");
const webpackDevMiddleware = require("webpack-dev-middleware");
const webpackHotMiddleware = require("webpack-hot-middleware");
const config = require("./webpack.config");
const bs = require("browser-sync").create();

// 将webpack-hot-middleware/client?reload=true插入到webpack.config.js中entry配置项的前面
config.entry.unshift("webpack-hot-middleware/client?reload=true");
// 启动express服务器
let app = new (require("express"))();
let port = 9000;
let compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {publicPath: "/assets/"}));
app.use(webpackHotMiddleware(compiler));
app.get("/", (req, res) => res.sendFile(path.resolve(__dirname, "src/index.html")));
app.listen(port);


jsx中如果想要使用自定义的属性需要加上data-前缀
此外，对于style属性，值要写成对象形式，内层花括号表示json对象，外层花括号表示把内层对象当成表达式包起来
<span data-abc="123" style={{color: "red"}}></span>









