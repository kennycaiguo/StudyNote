Linux分为内核版本和发行版本

目前最新的内核版本

不同的发行版本经过扩展一些功能或删除一些功能就是发行版本

Linux的开源软件有Apache Nginx MySQL PHP mongodb Python ruby

Linux主要应用于企业服务器和嵌入式应用

Linux与windows的不同
1、Linux严格区分大小写
2、Linux中所有内容以文件形式保存，包括硬件 用户也是文件
3、Linux中没有扩展名 不靠扩展名区分文件类型 是靠权限来区分的 但是有些约定俗成的扩展名
	压缩包 *.gz *.bz2 .tar.bz2 .tgz
	二进制软件包 .rpm
	网页文件 .html .php
	脚本文件 .sh
	配置文件 .conf
4、windows下的程序不能直接在Linux中安装和运行

VMware_Install_Cleaner帮助我们把虚拟机删干净


虚拟机的网络配置
桥接：虚拟机和真实机通信的通道为真实机的有线或无线网卡这种方法配置简单，但是会占用真实机网段内的一个IP

NAT Host-only如果选择了这两个选项的话，虚拟机只能和真实机通信而不能和局域网内其他机器通讯 NAT和Host-only的区别在于选择了NAT虚拟机是可以上网的

推荐使用桥接，较为方便

磁盘分区的要求（不论是Linux还是Windows，只要硬盘结构不变，硬盘分区的要求都是一样的）
最初的时候硬盘上只有主分区一种分区类型，但是主分区最多只能有4个
为什么只能分4个呢？这是有硬盘的结构决定的
硬盘被分为了一个一个等大小的扇区，每个扇区是512字节，其中446个字节用来记录我们的启动信息，还有2个字节是存放启动分区的标志，剩下的64个字节用来分区表示的，64个字节中每16个字节是一个分区表示，所以最多有4个主分区

由于最多只能分4个主分区，这样会带来很多不便，因此我们拿出一个主分区来作为扩展分区，扩展分区对一块硬盘来讲，最多只能有1个，这个是规定，没什么好说的

扩展分区不能写入数据，只能包含逻辑分区

格式化
格式化（高级格式化）又称逻辑格式化，它是根据用户选定的文件系统（FAT16 FAT32 NTFS EXT2 EXT3 EXT4等），在磁盘的特定区域写入特定的数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间

FAT32支持最大分区大小为16T，但是单个文件大小最大只能是4G，U盘通常是这种文件系统的
NTFS是目前最为先进的文件系统，支持更大的分区和更大的单个文件

Linux中的文件系统用的是EXT2 EXT3 EXT4，CentOS6中默认是EXT4

默认情况下格式化之后硬盘被分为以4KB为单位的很多块空间(数据块block)

假如有10K大小的一个文件，会被分为4K 4K 2K三个大小的块存在硬盘中，但是不一定是连续存储
而每个分区很大，有好几十G甚至上百G，因此硬盘必然存在一种查找规则，根据该规则将构成待查找文件的各个块找到拼接起来，格式化除了将硬盘分为一个个小格之外，还会做一个分区列表，这个列表记录了文件的ID号，文件的修改时间，文件的权限，组成文件的各个小块保存到了哪些位置
文件id号通常称作i节点(inode)

Windows中每个磁盘都有盘符

Linux下的硬件设备文件名
IDE硬盘			/dev/hd[a-d]	第一个/就代表根目录 一级目录dev下面是专门用来放硬件设备的
SCSI/SATA/USB硬盘	/dev/sd[a-p]
光驱			/dev/cdrom或/dev/hdc
软盘			/dev/fd[0-1]
打印机（25针）		/dev/lp[0-2]
打印机（USB）		/dev/usb/lp[0-15]
鼠标			/dev/mouse

Linux下的分区设备文件名
/dev/hda1		IDE硬盘接口
/dev/sda1		SCSI硬盘接口 SATA硬盘接口
注：hd或sd代表硬盘接口的类型 a代表第一块硬盘，如果是b就是第二块硬盘 1代表第一个分区

Linux分区表示
如果分了一个主分区，剩下的空间都分成了扩展分区，在扩展分区里面又分了3个逻辑分区，那么逻辑分区的编号是5 6 7
因为1 2 3 4这四个数字已经被主分区占用了，所以即使主分区不够四个，逻辑分区也不可以占用这四个数字，只能从5开始
总之，逻辑分区只能从5开始

盘符是windows的概念，Linux里面没有盘符这个东西
我们把分配的盘符叫做挂载点 给分区分配盘符的过程叫挂载
Linux中我们拿目录作为盘符
绝大多数目录都可以作为一个分区，包括我们自己手动建立的目录

必须分区：
/			根分区
swap分区	交换分区，其实类似虚拟内存，内存2倍(内存小于4G时)，不超过2GB(内存大于4G时)
必须分区是必须要分的，否则Linux启动不起来

推荐分区
/boot		启动分区 200MB
计算机的启动是需要几十兆的空间的，虽然很小，但是一旦我们的硬盘连几十兆的剩余空间都没有了，那就启动不起来了，所以推荐给boot分出一个分区

Linux常用命令（必须要知道的大约有60-70个左右）
命令基本格式
[root@localhost ~]#
root		当前登录用户 root是管理员账户
localhost	主机名
~		当前所在目录（家目录） 用户初始登录位置就是家 对于管理员root来说，家目录就是/root，		如果是普通用户，家目录是/home/myj/ 即/home/用户名/
#		超级用户的提示符
		普通用户的提示符是$

命令格式 [选项] [参数] 选项和参数有时是可选的
注：个别命令不遵循这个格式 当有多个选项时，可以写在一起 完整选项有其对应的简化选项 例如--all的简化选项是-a

ls [选项] [文件或目录]
选项：
	-a 显示所有文件 ls -a指令可以看到所有的文件，执行这个指令之后我们能看到一些隐藏文件，这些文件都是以.开头的，Linux中以.开头的文件是隐藏文件
	-l long list长格式显示 查看详细信息
		-rw-------. 1 root root 1207 1月 14 18:18 anaconda-ks.cfg
		-rw-------	开始的十位代表权限 
			第一位代表文件类型 
			-	文件类型 Linux中总共有7种，常见的有以下三种
				-	普通文件
				d	目录
				l	软链接文件(快捷方式)
			后九位三位一组 代表这个文件的"u所有者 g所属组 o其他人"三个身份
				r读 w写 x执行 用户对文件的权限只有读写执行三种
		第十一位.代表ACL权限，是CentOS6之后才有的
		接下来的数字1代表引用计数 代表这个文件被调用过几次
		接下来的root是这个文件的所有者
		接下来的root是所属组，这里是root组
		接下来的1207是文件大小，单位是字节 指令中的选项如果加上h(humman) 即ls -lh，就可以以可读性较为友好的方式显示 所有统计大小的命令都支持h选项
		接下来的 1月 14 18:18 是最后一次修改的时间
		最后的anaconda-ks.cfg是文件名
	-d 查看目录属性 如果我们执行ls -l /etc/指令，那么查找到的是etc目录下文件的信息，而如果希望查看etc目录本身的信息就需要加上选项d 即ls -ld /etc/
	-h 人性化显示
	-i 显示inode Linux中每个文件都有一个id号(inode号)，我们系统是通过这个id号来判断文件的位置的ls -i就可以查看它的id号

文件处理命令
1）目录处理命令
2）文件处理命令
3）链接命令

Linux中目录也是文件，但是目录文件其实就是文件夹，而普通文件是存放数据的文件

建立目录 mkdir -p [目录名] -p意思是递归创建
mkdir aaa这条指令会创建aaa文件夹
mkdir -p bbb/ccc 会先在当前目录下创建bbb文件夹，再在bbb文件夹下面创建ccc文件夹，如果不加-p是会报错的，创建会失败

切换目录 cd /root回到根下的root目录，也就是家目录，ctrl+L快捷键清屏
cd ~回到家目录
cd -进入上次所在目录
cd ..进入上一级目录
cd .切换到当前目录，实际上没有意义，因为没有动

查询所在目录位置 pwd
删除空目录 rmdir 这条命令只能删除空白目录

rm -rf [文件或目录] 这里的-r参数是删除目录或文件 但是如果只加-r的话这个目录下有多少文件就会提示多少次是否真的删除，但是加上-f (force) 这个参数之后就不会有提示，直接会删除，而且是永久性删除

rm -rf / 这条命令是可以执行的，在早期会删掉Linux根目录下所有文件，现在的Linux版本会删除99%的文件

复制命令 cp [选项] [原文件或目录] [目标目录]
-r 复制目录
-p 连带文件属性复制
-d 若源文件是链接文件，则复制链接属性
-a 相当于 -pdr 加了-a，源文件和目标文件完全相同

date 显示当前系统时间

ll命令相当于ls -l

剪切或改名命令 mv [原文件或目录] [目标目录] 注意没有-r
如果原文件和目标文件在一个目录下就是改名，否则就是剪切

根目录下有bin和sbin，/usr下也有bin和sbin，这四个目录都是用来保存系统命令的，两个bin目录下的命令是任何用户都可以执行的，而两个sbin目录下的命令只有超级用户可以执行
/boot是启动目录
/etc是系统默认保持配置文件的目录，后期学习服务会经常用到
/home是普通用户的家目录
/root是超级用户的家目录
/lib是Linux中函数库目录 相当于c语言中include包含的外部文件
/media /mnt /misc是三个系统挂载目录
/proc和/sys目录不能直接操作，这两个目录保存的是内存的过载点，这两个文件夹里面的内容是直接写在内存中的 我们不能直接往这两个文件夹里面存储数据
/tmp 存放临时数据
/usr系统软件资源目录
	/usr/bin
	/usr/sbin

综上，我们最好只在家目录/root或/home，以及/tmp目录下存放东西，别的都不要随便动
也不要在根目录下放很多文件或文件夹

链接命令
链接命令用来把一个原文件生成一个目标文件 ln -s [原文件] [目标文件] 目标文件不写文件名时文件名就和原文件是一样的，例如ln -s /root/anaconda-ks.cfg /tmp/
这条指令将在/tmp/下创建一个名为anaconda-ks.cfg的文件
分为软链接和硬链接
-s 是创建软链接的选项 soft

硬链接的特征
拥有相同的i节点和存储block块，可以看做是同一个文件
可以通过i节点识别
不能跨分区
不能针对目录使用

分区表用来保存文件的i节点(唯一标识)、时间、存储位置等信息
用户希望打开一个文件的时候不是直接从硬盘上查找，而是先要在分区表中查找到该文件的存储位置信息，然后再去硬盘上找这个存储位置，将数据拿出来
如果现在有一个a文件，还有一个b文件，b文件和a文件只是名字不同，但是存储位置相同，相当于a和b这两个名字都指向了同一个文件，这就是硬链接

硬链接自身有一定局限性，因此不推荐使用

软链接
类似windows下的快捷方式
软链接拥有自己的i结点和block块，但是数据块中只保存原文件的文件名和i结点号
lrwxrwxrwx l软链接 软链接的文件权限都是rwxrwxrwx
修改任意文件，另一个都改变
删除原文件，链接文件就不可以使用了

执行软链接指令时一定要写绝对路径

文件搜索命令
文件搜索命令locate 比find块 locate 文件名 但是功能较弱，只能按照文件名搜索
命令搜索命令whereis which
文件搜索命令find 较慢 但是功能强大
字符串搜索命令grep
find命令与grep命令的区别

/var/lib/mlocate locate命令所搜索的是这个后台数据库
我们如果用locate搜索新建的文件时是不成功的，因为新建的文件需要过一天才会加到上面这个后台数据库中，这时我们可以通过updatedb强制将该文件加到数据库中，但locate只能按照文件名搜索

locate命令是按照/etc/updatedb.conf这个配置文件里面的筛选规则搜索的
PRUNE DING_MOUNTS="yes" 如果DING_MOUNTS是yes，那么配置文件中所有的筛选规则都生效，反之都不生效
PRUNEFS="..." locate命令不搜索PRUNEFS里面的文件系统下的文件
PRUNENAMES=".git .hg .svn" locate命令不搜索PRUNENAMES里面的文件类型的文件
PRUNEPATHS="..." locate命令不搜索PRUNEPATHS里面的文件夹下更新的文件

whereis -bm
搜索命令所在路径及帮助文档所在位置
-b 只查找可执行文件
-m 只查找帮助文件

whereis ls这个命令就是查看ls这个命令的位置

which ls有时还会显示出ls命令的别名，例如ls -l的别名就是ll
ls的别名就是ls --color=auto

whereis和which是找不到cd命令的位置（可执行文件）的，因为cd命令是shell自带的命令
whereis和which访问的是外部安装的命令

严格上来讲，我们输入命令的时候必须输入绝对路径命令才会生效，例如ls命令其实应该输入/bin/ls，但是这样很不方便，所以Linux系统为我们提供了$PATH这个环境变量：
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/home/myj/bin

find [搜索范围] [搜索条件]
find / -name install.log 名字必须是install.log完全匹配
find /root -name "install.log*" 注意一定要加引号
find /root -iname install.log -iname不区分大小写
find /root -nouser 搜索没有所有者的文件（绝大多数是垃圾文件） 内核产生的文件可能没有所有者 在windows中建立的外来文件拷贝到Linux中也没有所有者，剩下的文件都应该有所有者
find /root -user root 按照所有者搜索

find /var/log/ -mtime +10
-10 10天内修改文件
10  10天当天修改的文件
+10 10天前修改的文件

atime 文件访问时间 access
ctime 改变文件属性 change
mtime 修改文件内容 modify

find /root -size 25k 搜索大小是25k的文件 注意k是小写
find /root -size +25M 搜索大于25M的文件 注意M是大写
find /root -size 25不写单位的话默认是数据块，但是还不是分区的数据块(4K)，而是硬盘扇区的数据块(512字节)
find . -inum 262422 查找i节点是262422的文件
find /etc -size +20k -a -size -50k 大于20小于50的文件 -a是and 且 -o是or 或
find /etc -size +20k -a -size -50k -exec ls -lh {} \; 意思是find /etc -size +20k -a -size -50k命令找到的结果交给ls -lh命令执行
-exec/-ok命令{} \;对搜索结果执行操作

搜索字符串命令
grep [选项] 字符串 文件名 在文件当中匹配符合条件的字符串
-i 忽略大小写
-v 排除指定字符串

find是搜文件名的 grep是搜文件种的字符串的
find是完全匹配，grep是包含匹配
find使用通配符匹配，grep使用正则表达式匹配

帮助命令man manul
man 命令

man ls 查看ls的帮助文档

查看命令拥有哪个级别的帮助
man -f 命令 相当于
whatis 命令

找到和passwd命令相关的所有帮助信息
man -k passwd

ls --help可以以中文方式显示ls下所有选项的帮助信息

shell就是Linux的壳，壳包着内核
shell将我们敲的指令编译之后传递给内核

whereis cd 用whereis确定cd是不是shell内部命令

内部命令不能用man cd来查看帮助文档，需要用help cd才可以
help是专门获取内部命令的帮助文档的指令

info 命令
	带有*的地方敲回车 查看详细帮助

压缩与解压缩命令
常用压缩格式 .zip  .bz2  .gz  .tar.gz  .tar.bz2

zip的压缩和解压缩
	压缩文件：zip 压缩文件名 源文件
	压缩目录：zip -r 压缩文件名 源目录

	Linux中的软件包都是以红色显示的，包括压缩包

	解压缩文件 unzip 压缩文件
gz的压缩和解压缩
	gzip 源文件 压缩为.gz格式的压缩文件，源文件会消失
	gzip -c 源文件 > 压缩文件 压缩为.gz文件，源文件会保留
	gzip -r 源目录 压缩目录下所有的子文件

	gzip -d 压缩文件 解压缩文件
	gunzip 压缩文件 解压缩文件
bzip2
	bzip2 源文件 压缩为.bz2格式，不保留源文件
	bzip2 -k 源文件 压缩之后保留源文件
	bzip2不能压缩目录
	bzip2 -d 压缩文件 解压缩，-k保留压缩文件
	bunzip2 压缩文件 解压缩 -k保留压缩文件

.gz和.bz2在压缩目录的时候都会有问题，所以Linux提供了.tar.gz和.tar.bz2两种格式，这两种格式其实是将目录打包后的格式，然后再将该格式的文件(实际上是被压缩了的目录)压缩成.gz和.bz2两种格式

tar -cvf 打包文件名 源文件
	-c 打包
	-v 显示过程
	-f 指定打包后的文件名
例如 tar -cvf jp.tar jp 这条指令就是将jp这个目录压缩成jp.tar这个包
接下来再执行bzip2 jp.tar就得到了jp.tar.bz2文件了

解压命令
tar -xvf 打包文件名
	-x 解压缩

事实上我们可以通过添加-z参数将上面打包成tar的这一步合并进去
tar -zcvf 压缩包名.tar.gz 源文件
	-z 压缩为.tar.gz格式
tar -zxvf 压缩包名.tar.gz
tar -jcvf 压缩包名.tar.bz2 源文件
tar -jxvf 压缩包名.tar.bz2
tar -jxvf 压缩包名.tar.bz2 -C /tmp/ -C指定解压缩到哪个地方，这里添加了/tmp/就代表解压缩到该目录下 -C选项一定要写在最后面
tar -zcvf /tmp/test.tar.gz jp anaconda-ks.cfg同时压缩jp和anaconda-ks.cfg两个文件，并且压缩到/tmp/下
tar -ztvf test.tar.qz 这里第二个参数变成了t，代表只是看看压缩文件里面有什么，但是并不真正解压缩

关机与重启命令
shutdown [选项]时间
	-c 取消前一个关机命令
	-h 关机
	-r 重启
如果希望立即关机或重启时间就写now：shutdown -h now立即关机
但是如果直接写shutdown -h 05:30这条命令执行之后，操作系统就会卡在那里，一直等到5:30关机，这时需要加上&符号来解决
shutdown -r 5:30 &

halt
poweroff
init 0
以上三条都会执行关机，但是这三个命令比较危险，因为这三条命令在关机前不会给出任何提示去保存当前服务或进程

reboot
init 6
以上2条都会执行重启

我们具体来看下init后面的0或6是什么意思 这个数字代表系统运行的级别
0	关机
1	单用户		启动最小程序，类似windows的安全模式
2	不完全多用户，不含NFS服务
3	完全多用户
4	未分配
5	图形界面
6	重启

runlevel指令用于查看系统运行的级别，执行之后得到
N 3 //N代表进入3级别之前的级别(N是空的意思null)   3代表当前系统运行的级别
例如通过图形界面进入字符界面那么runlevel执行后就会得到5 3

如果我们既安装了图形界面，又安装了字符界面，那么开机进入哪个界面是可以设置的
cat /etc/inittab
进入这个文件之后我们可以看到很多注释，只有最后一行不是注释:
id:3:initdefault这里定义了启动之后进入哪种界面

当然id后面一定不可以写0或6，否则Linux一开机就会重启

logout退出登录

挂载命令
Linux中所有的存储设备(U盘、硬盘、光盘)都必须挂载之后才能运行，相当于windows中的盘符，我们Linux中拿系统目录来作为盘符

如果使用光盘或U盘时，需要手动挂载，在windows中其实也有分配盘符的过程，只是windows里分配盘符是自动的

查询与自动挂载
mount 查询系统中已经挂载好的设备
/dev/sda5 on / type ext4(rw)	这句的意思就是第一块硬盘的第一个逻辑分区就是根分区
/dev/sda5是设备文件名，我们通过访问/根目录就能访问到里面的数据
		dev设备是保存所有硬件设备的目录
		sd代表SCSI或SATA接口硬盘
		a代表第一块硬盘
		5代表第1个逻辑分区
ext4是其文件系统

执行mount之后我们看到除了/dev/sda5这样的目录之外还有/proc /sys这样的目录，但是这些都是系统内存的目录，不能动

mount -a 依据配置文件/etc/fstab的内容，自动挂载
	/etc/fstab 是Linux中自动挂载的文件

mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点
-t文件系统：加入文件系统类型来指定挂载的类型，可以是ext3,ext4,iso9660(光盘默认的文件系统)等文件系统
	注：Linux标准文件系统是ext3 ext4 centOS6以上的文件系统是ext4
-o特殊选项：可以指定挂载的额外选项
设备文件名：像/dev/sda5这样的分区 如果要是挂载光盘或者U盘的话有固定的挂载点
挂载点：盘符

接下来我们看-o特殊选项


====================================================================================网络编程
应用层 表示层 会话层 为应用服务
传输层 网络层 数据链路层 物理层 为数据服务

不同层的数据单位是不一样的：
物理层 比特
数据链路层 帧
网络层 报文


TCP/IP歇息4层模型
应用层
传输层
网际互联层
网络接口层


ftp 文件传输协议 20 21
ssh 安全shell协议 22
telnet 远程登录协议 23
DNS 域名系统 53
http 超文本传输协议 80
SMTP 简单邮件传输协议 25
POP3 邮局协议3代 110

netstat -an
-a 所有连接和监听端口
-n 显示IP地址和端口号，不显示域名和服务
netstat中的stat代表status（状态）


根域
顶级域(一级域)
	组织域	com gov net org
	国家或地区域 cn jp uk au hk
二级域(需要买)
	imooc Microsoft IBM
主机名(三级域)
	www news map
	
三级域 + 二级域 + 一级域 三个连接在一起

网络==============================================
ifconfig查看ip信息
eth0 Link encap:Ethernet HWaddr 52:54:AB:DD:6F:61

　　inet addr:210.34.6.89 Bcast:210.34.6.127 Mask:255.255.255.128

　　UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1

　　RX packets:46299 errors:0 dropped:0 overruns:0 frame:189

　　TX packets:3057 errors:0 dropped:0 overruns:0 carrier:0

　　collisions:0 txqueuelen:100

　　Interrupt:5 Base address:0xece0


service network restart 重启网络服务

虚拟机和真实机通信步骤========================
1、虚拟机配置IP地址
2、将ifcfg-eth0文件中ONBOOT=no 改为ONBOOT=yes
3、修改UUID
	vi /etc/sysconfig/network-scripts/ifcfg-eth0
	删除MAC地址行
	
	rm -rf /etc/udev/rules.d/70-persistent-net.rules
	删除网卡和MAC地址绑定文件
	
	重启系统
4、与真实机通信方式
	安装完虚拟机之后在控制面板-网络连接中会多出VMNet1和VMNet8两块虚拟网卡
	桥接模式：虚拟机和真实机使用真实网卡（即宿主机的网卡）进行通信
	NAT模式：虚拟机和真实机使用VMNet8进行通信，不可以同局域网中其他机器通信，可以访问公网
	HOST-ONLY模式：虚拟机和真实机使用VMNet1进行通信，不可以同局域网中其他机器通信，不可以访问公网
5、